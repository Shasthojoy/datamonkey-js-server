startWithRateClasses	= 2;maxRateClasses			= 10;rateClassesCount 		= startWithRateClasses; autoStepFlag	 		= 1;modelSpawnPrefix = "";modelSpawnPrefix * 128;modelSpawnSuffix = "";modelSpawnSuffix * 128;/*---------------------------------------------------------------------------------------------------------------------------------------------*/produceOffspring		= MPI_NODE_COUNT-1;populationSize  		= 2*produceOffspring;incestDistance  		= 0;generationCount		  	= 10000;maxSampleTries			= populationSize*10;mutationThreshhold		= 0.0001;mutationProb			= 0.15;mutationProbDecrease	= 0.95;annealingPhase			= 100;SHORT_MPI_RETURN		= 1;totalSampleCounter		= 0;localMutationRate		= 0.05;localMutationInterval	= 20;stoppingCriterion		= 50;sampleCount				= 0;familyControlSize		= produceOffspring$6;predef   				= {};MasterList				= {};RatesList				= {};verboseFlag				= 0;stateVectorDimension    = 190;predef   				= {};/*---------------------------------------------------------------------------------------------------------------------------------------------*/function ExportAMatrix2 (fileName, rateMatrix, aic_score, rateAVL){	fprintf (fileName, aic_score, "\n{");	for (kr=0; kr<Rows (rateMatrix); kr=kr+1)	{		fprintf (fileName, "{", rateAVL["NSR"+rateMatrix[kr]], "}\n");	}	fprintf (fileName, "}\n");	return 0;}/*---------------------------------------------------------------------------------------------------------------------------------------------*/function ExportAMatrix (fileName, rateMatrix, doClear){	outString = "";	outString * 256;	outString * "branchAssignments={};\n";	for (nodeCounter = 0; nodeCounter < stateVectorDimension; nodeCounter = nodeCounter+1)	{		outString * ("branchAssignments[\""+branchNames[nodeCounter]+"\"] = " + rateMatrix[nodeCounter] + ";\n");	}	outString * 0;	if (doClear)	{		fprintf (fileName, CLEAR_FILE,outString);	}	else	{		fprintf (fileName,"\n",outString);	}	return 0;}/*---------------------------------------------------------------------------------------------------------------------------------------------*/function MatrixToString (rateMatrix){	outString = "";	outString * 256;	for (h=0; h<stateVectorDimension; h=h+1)	{		outString * (","+rateMatrix[h]);					}	outString * 0;	return outString;}/*---------------------------------------------------------------------------------------------------------------------------------------------*/function CleanUpMPI (dummy){	if (MPI_NODE_COUNT>1)	{		while (1)		{			for (nodeCounter = 0; nodeCounter < MPI_NODE_COUNT-1; nodeCounter = nodeCounter+1)			{				if (MPINodeState[nodeCounter][0]==1)				{					fromNode = ReceiveJobs (0,0);					break;					}			}			if (nodeCounter == MPI_NODE_COUNT-1)			{				break;			}		}				}	return 0;}/*---------------------------------------------------------------------------------------------------------------------------------------------*/function ReceiveJobs (sendOrNot, ji){	if (MPI_NODE_COUNT>1)	{		MPIReceive (-1, fromNode, result_String);		mji = MPINodeState[fromNode-1][1];		mdf	= MPINodeState[fromNode-1][2];				if (sendOrNot)		{			MPISend (fromNode,msg2Send);			MPINodeState[fromNode-1][1] = ji;						MPINodeState[fromNode-1][2] = modelDF;					}		else		{			MPINodeState[fromNode-1][0] = 0;			MPINodeState[fromNode-1][1] = -1;				}		ExecuteCommands (result_String);		myDF	  = lf_MLES[1][1] + baseParams - 1;		myAIC 	  = 2*(lf_MLES[1][0]-myDF*sampleCount/(sampleCount-myDF-1));		myLFScore = lf_MLES[1][0];		ji = mji;	}	else	{		myDF	  = modelDF + baseParams;		myAIC 	  = 2*(lf_MLES[1][0]-myDF*sampleCount/(sampleCount-myDF-1));		myLFScore = res[1][0];	}		if (resultProcessingContext==0)	{		sortedScores[ji][0] = myAIC;	}	else	{		intermediateProbs[ji][0] = myAIC;		}	if (ji>=0)	{		if (resultProcessingContext==0)		{			ExportAMatrix2 (detailedResultPath,StringToMatrix(currentPopulation[ji]),-myAIC,lf_MLE_VALUES);			sortedBP = MatrixToString (currentPopulation[ji]);			MasterList [sortedBP] = myAIC;			RatesList  [sortedBP] = lf_MLE_VALUES;		}		else		{			ExportAMatrix2 (detailedResultPath,StringToMatrix(children[ji-populationSize]),-myAIC,lf_MLE_VALUES);				sortedBP = MatrixToString (children[ji-populationSize]);			MasterList [sortedBP] = myAIC;			RatesList  [sortedBP] = lf_MLE_VALUES;		}				totalSampleCounter = totalSampleCounter + 1;	}	return fromNode-1;}/*---------------------------------------------------------------------------------------------------------------------------------------------*/function RunASample (modelDF, jobIndex){	sampleString = MatrixToString (cString);	myAIC = MasterList[sampleString];		if (myAIC < (-0.1))	{		if (resultProcessingContext==0)		{			sortedScores[jobIndex][0] = myAIC;		}		else		{			intermediateProbs[jobIndex][0] = myAIC;			}					return 0;	}			msg2Send = "";	msg2Send * 128;	msg2Send * ("presetBranchParameters = "+currentBLEstimates+";bClasses="+cString+";");		msg2Send * modelSpawnPrefix;	msg2Send * ("AC:="+AC+";\n");	msg2Send * ("AT:="+AT+";\n");	msg2Send * ("CG:="+CG+";\n");	msg2Send * ("CT:="+CT+";\n");	msg2Send * ("GT:="+GT+";\n");	msg2Send * modelSpawnSuffix;	msg2Send * 0;			if ((MPI_NODE_COUNT>1) && (jobIndex>=0))	{		for (mpiNode = 0; mpiNode < MPI_NODE_COUNT-1; mpiNode = mpiNode+1)		{			if (MPINodeState[mpiNode][0]==0)			{				break;				}		}		if (mpiNode==MPI_NODE_COUNT-1)		{			mpiNode = ReceiveJobs (1,jobIndex);		}		else		{			MPISend (mpiNode+1,msg2Send);			MPINodeState[mpiNode][0] = 1;			MPINodeState[mpiNode][1] = jobIndex;			MPINodeState[mpiNode][2] = modelDF;		}	}	else	{		Optimize (res,lf);		if (jobIndex>=0)		{			mpiNode = ReceiveJobs (1, jobIndex);		}		else		{			myAIC 	  = 2*(res[1][0]-(baseParams+modelDF)*sampleCount/(sampleCount-baseParams-modelDF-1));		}	}	return 0;}/*---------------------------------------------------------------------------------------------------------------------------------------------*/function BuildCodonFrequencies (obsF){	PIStop = 1.0;	result = {ModelMatrixDimension,1};	hshift = 0;	for (h=0; h<64; h=h+1)	{		first = h$16;		second = h%16$4;		third = h%4;		if (_Genetic_Code[h]==10) 		{			hshift = hshift+1;			PIStop = PIStop-obsF[first][0]*obsF[second][1]*obsF[third][2];			continue; 		}		result[h-hshift][0]=obsF[first][0]*obsF[second][1]*obsF[third][2];	}	return result*(1.0/PIStop);}/*---------------------------------------------------------------------------------------------------------------------------------------------*/function SpawnRandomString (clsCnt){	rModel = {stateVectorDimension,1};	for (h=0; h<stateVectorDimension; h=h+1)	{		rModel[h] = Random(0,clsCnt)$1;	}		return MakeStringCanonical(rModel,clsCnt);}/*---------------------------------------------------------------------------------------------------------------------------------------------*/function MakeStringCanonical (randomModel, classCount){	compressedString = {classCount,1};	for (h=0; h<stateVectorDimension; h=h+1)	{		v = randomModel[h];		compressedString[v] = 1;	}	compressedString[0] = 0;	for (h=1; h<classCount; h=h+1)	{		compressedString[h] = compressedString[h]+compressedString[h-1];	}	for (h=0; h<stateVectorDimension; h=h+1)	{		v = randomModel[h];		v = compressedString[v];		randomModel[h] = v;	}	v = compressedString[classCount-1]+1;	if (v>1)	{		sortedOrder = {v,2};		for (h=0; h<v; h=h+1)		{			sortedOrder[h][0] = -1;		}		cc = 0;		for (h=0; h<stateVectorDimension; h=h+1)		{			hshift = randomModel[h];			if (sortedOrder[hshift][0] < 0)			{				sortedOrder[hshift][0] = cc;				sortedOrder[hshift][1] = hshift;				cc = cc+1;			}		}		sortedOrder = sortedOrder%1;		for (h=0; h<stateVectorDimension; h=h+1)		{			v = randomModel[h];			randomModel[h] = sortedOrder[v][0];		}			}	return randomModel;}/*---------------------------------------------------------------------------------------------------------------------------------------------*/function StringToMatrix (stringSpec){	return stringSpec;}/*---------------------------------------------------------------------------------------------------------------------------------------------*/function IsChildViable (putativeChild){	sampleString 	= MatrixToString (putativeChild);	myAIC 			= MasterList[sampleString];	testChild 		= putativeChild;	mutPassCount 	= 1;		while (myAIC < (-0.1) && mutPassCount < 20)	{		if (verboseFlag)		{			fprintf (stdout,"Adjusting the child to avoid a duplicate. Pass ", mutPassCount, "\n");		}				mutPassCount = mutPassCount + 1;		sampleString = Min(Random(0,stateVectorDimension)$1,stateVectorDimension-1);		myAIC 		 = testChild[sampleString];				newValue = Random (0,rateClassesCount-0.0000001)$1;		while (newValue == myAIC)		{			newValue = Random (0,rateClassesCount-0.0000001)$1;		}				testChild [sampleString] = newValue;		testChild 				 = MakeStringCanonical (testChild, rateClassesCount);		sampleString 			 = MatrixToString (testChild);		myAIC 		 			 = MasterList[sampleString];	}	return testChild;}/*---------------------------------------------------------------------------------------------------------------------------------------------*/function UpdateBL (dummy){	bestInd							= sortedScores[populationSize-1][1];	dNdSBranchClasses 				= StringToMatrix(currentPopulation[bestInd]);	MG94custom = 0;	MULTIPLY_BY_FREQS 				= PopulateModelMatrix ("MG94custom", observedFreq);	Model MG94customModel 			= (MG94custom,vectorOfFrequencies,0);	AC=AC;	AT=AT;	CG=CG;	CT=CT;	GT=GT;		Tree givenTree				    = treeString;	ClearConstraints				(givenTree);	ReplicateConstraint 			("this1.?.synRate:=3*this2.?.t", givenTree, nucTree); 	ClearConstraints				(givenTree);		bNames  	 = BranchName (givenTree,-1);		definedOrNot = {};	for (brCount = 0; brCount < stateVectorDimension; brCount = brCount + 1)	{		cbc	= dNdSBranchClasses[brCount];		if (definedOrNot[cbc] == 0)		{			definedOrNot[cbc] = 0;			ExecuteCommands ("global NSR"+cbc+"=1;");		}		tn = bNames[brCount];		ExecuteCommands ("givenTree." + tn + ".nonSynRate:= NSR" + cbc + "*givenTree." + tn +".synRate;");	}		LikelihoodFunction 				lf = (filteredData,givenTree);		/*if (filteredData.species > 10 && filteredData.unique_sites/(MPI_NODE_COUNT) > 10)	{		AUTO_PARALLELIZE_OPTIMIZE		= 1;	}*/	if (verboseFlag)	{		VERBOSITY_LEVEL 			= 1;	}	Optimize 						(res,lf);	AUTO_PARALLELIZE_OPTIMIZE		= 0;		VERBOSITY_LEVEL 				= 0;		AC:=AC__;	AT:=AT__;	CG:=CG__;	CT:=CT__;	GT:=GT__;	myDF									= res[1][1] + 9;		myAIC 	  								 = 2*(res[1][0]-myDF*sampleCount/(sampleCount-myDF-1));	if (verboseFlag)	{		fprintf									 (stdout, "\nUpdated BLs\nAICs: ", -myAIC, "\t",  -sortedScores[populationSize-1][0], "\n", lf, "\n");	}	newBE = BranchLength (givenTree,-1)*3;	fprintf ("Branchcheck.log", sortedScores[populationSize-1][0], ":", myAIC, "\n", newBE, "\n");		if (sortedScores[populationSize-1][0] < myAIC)	{		currentBLEstimates 						 = newBE;		sortedScores[populationSize-1][0] 		 = myAIC;		MasterList[sampleString] 				 = myAIC;	}	return 0;}/*---------------------------------------------------------------------------------------------------------------------------------------------*//*---------------------------------------------------------------------------------------------------------------------------------------------*/fscanf  			(stdin,"String",_in_FilePath);fscanf				(stdin,"Number", _in_GeneticCodeTable);fscanf  			(stdin,"String",_in_ModelDescription);fscanf				(stdin,"Number",treeMode);if (treeMode > 1){	treeMode = 1;}timer = Time(1);skipCodeSelectionStep    = 1;ExecuteAFile			("../Shared/chooseGeneticCode.def");ExecuteAFile			("../Shared/globals.ibf");ExecuteAFile			("../Shared/GrabBag.bf");ApplyGeneticCodeTable (_in_GeneticCodeTable);modelDesc			= _in_ModelDescription;rootOn 				= "";GetURL 				(dataFileString,BASE_URL_PREFIX+MANGLED_PREFIX+"/"+_in_FilePath);analysisSpecRaw     = _getRawTreeSplits (_in_FilePath, "treeMode", "rootOn");fprintf				(stdout, analysisSpecRaw);baseFilePath  		= "spool/"+_in_FilePath;progressFilePath	= baseFilePath + ".progress";modelFile			= baseFilePath + ".out";ExecuteAFile			("../Shared/_MFReader_.ibf");fprintf (progressFilePath, CLEAR_FILE);fprintf (modelFile, CLEAR_FILE);treeString 		= myTrees[0];DataSetFilter	filteredData = CreateFilter(ds_0,3,"","",GeneticCodeExclusions);fscanf ("_BMS_Aux.ibf","Raw",sampleCount);ExecuteCommands (sampleCount);fileSpec		 = "spool/"+_in_FilePath;fprintf (fileSpec, CLEAR_FILE, dataFileString);modelSpawnPrefix * sampleCount;modelSpawnPrefix * ("DataSet 	ds  = ReadDataFile (\""+BASE_CLUSTER_DIR + "Analyses/GABranch/" + fileSpec + "\");\n");modelSpawnPrefix * ("GeneticCodeExclusions = \"" + GeneticCodeExclusions + "\";\n");modelSpawnPrefix * ("_Genetic_Code = " + _Genetic_Code + ";\n");modelSpawnPrefix * ("DataSetFilter	filteredData = CreateFilter(ds,3,\"\",\"\",GeneticCodeExclusions);\n");modelSpawnPrefix * 0;sampleCount 				 = filteredData.sites;/*---------------------------------------------------------------------------------------------------------------------------------------------*/global AC = 1;global AT = 1;global CG = 1;global CT = 1;global GT = 1;catCounterAL = {stateVectorDimension,1};MGCustomRateBiasTerms = {{"AC*","","AT*","CG*","CT*","GT*"}};			paramCount	   = 0;_nucBiasTerms  = {4,4};_nucBiasTerms[0][0] = "";if (modelDesc[0]==modelDesc[1]){	MGCustomRateBiasTerms[0] = MGCustomRateBiasTerms[1];}_nucBiasTerms[1][0] = MGCustomRateBiasTerms[0];_nucBiasTerms[0][1] = MGCustomRateBiasTerms[0];_nucBiasTerms[2][0] = MGCustomRateBiasTerms[1];_nucBiasTerms[0][2] = MGCustomRateBiasTerms[1];h = 0;v = 3;for (customLoopCounter2=2; customLoopCounter2<6; customLoopCounter2=customLoopCounter2+1){	for (customLoopCounter=0; customLoopCounter<customLoopCounter2; customLoopCounter=customLoopCounter+1)	{		if (modelDesc[customLoopCounter]==modelDesc[customLoopCounter2])		{			_nucBiasTerms[h][v] = MGCustomRateBiasTerms[customLoopCounter];			_nucBiasTerms[v][h] = MGCustomRateBiasTerms[customLoopCounter];			break;		}	}	if (customLoopCounter == customLoopCounter2)	{		_nucBiasTerms[h][v] = MGCustomRateBiasTerms[customLoopCounter2];		_nucBiasTerms[v][h] = MGCustomRateBiasTerms[customLoopCounter2];	}		v = v+1;	if (v==4)	{		h=h+1;		v=h+1;	}}_nucRateMatrix = {4,4};modelSpawnPrefix * ("_nucBiasTerms = {4,4};_nucBiasTerms[0][0] = \"\";\n");for (customLoopCounter = 0; customLoopCounter < 4; customLoopCounter = customLoopCounter + 1){	for (customLoopCounter2 = customLoopCounter+1; customLoopCounter2 < 4; customLoopCounter2 = customLoopCounter2 + 1)	{		ExecuteCommands ("_nucRateMatrix[" + customLoopCounter  + "][" + customLoopCounter2 + "]:=" + _nucBiasTerms[customLoopCounter][customLoopCounter2] + "t;");		ExecuteCommands ("_nucRateMatrix[" + customLoopCounter2 + "][" + customLoopCounter  + "]:=" + _nucBiasTerms[customLoopCounter2][customLoopCounter] + "t;");		modelSpawnPrefix * ("_nucBiasTerms[" + customLoopCounter + "][" + customLoopCounter2 + "] = \"" + _nucBiasTerms[customLoopCounter][customLoopCounter2] + "\";");		modelSpawnPrefix * ("_nucBiasTerms[" + customLoopCounter2 + "][" + customLoopCounter + "] = \"" + _nucBiasTerms[customLoopCounter2][customLoopCounter] + "\";");	}}DataSetFilter	nucFilter = CreateFilter(ds_0,1);HarvestFrequencies (nucFreq,nucFilter,1,1,1);Model 	nucModel = (_nucRateMatrix,nucFreq,1);Topology T		 = treeString;treeString		 = Format (T,0,0);Tree 	nucTree  = treeString;branchNames 		 = BranchName (nucTree,-1);stateVectorDimension = Columns (branchNames)-1;fprintf (progressFilePath, "<DIV CLASS='RepClassSM'>\nA total of ", stateVectorDimension, " branches. Fitting a nucleotide model to approximate branch lengths... </DIV>");LikelihoodFunction lf = (nucFilter,nucTree);Optimize (nuc_res,lf);currentBLEstimates   = BranchLength (nucTree,-1) * 3;fprintf ("Branchcheck.log", CLEAR_FILE, currentBLEstimates, "\n");fprintf (progressFilePath, "<DIV CLASS='RepClassSM'>Nucleotide LogL = ", nuc_res[1][0], "</DIV>");HarvestFrequencies (observedFreq,filteredData,3,1,1);/*---------------------------------------------------------------------------------------------------------------------------------------------*/detailedResultPath = modelFile;fprintf 		  (detailedResultPath,CLEAR_FILE,KEEP_OPEN,Format(nucTree,1,1),"\n",treeMode, "\n");dNdSBranchClasses = {stateVectorDimension,1};MG94plain = 0;MULTIPLY_BY_FREQS 				= PopulateModelMatrix ("MG94plain", observedFreq);vectorOfFrequencies 			= BuildCodonFrequencies (observedFreq);modelSpawnPrefix 				* ("observedFreq = " + observedFreq + ";\n");modelSpawnPrefix 				* ("vectorOfFrequencies = " + vectorOfFrequencies + ";\n");modelSpawnPrefix				* ("global AC = 1; global AT = 1; global CG = 1; global CT = 1; global GT = 1;\n");modelSpawnPrefix				* 0;Model MG94plainmodel	 		= (MG94plain,vectorOfFrequencies,0);/*treeString	   =   DATAFILE_TREE;*/Tree givenTree =   treeString;modelSpawnSuffix *	("MULTIPLY_BY_FREQS = PopulateModelMatrix (\"MG94custom\", observedFreq);\n");modelSpawnSuffix *  ("Model MG94customModel = (MG94custom,vectorOfFrequencies,0);\n");modelSpawnSuffix *	("Tree givenTree2 = " + treeString + ";\n");modelSpawnSuffix *	("replicateBranchLengths (0);\nLikelihoodFunction lf = (filteredData,givenTree2);\n");modelSpawnSuffix *	("Optimize (lf_MLES,lf);\nreturn makeReturnValue(0);\n");modelSpawnSuffix *  0;global 		   			codonBranchScaler = 1;ReplicateConstraint 	("this1.?.synRate:=3*this2.?.t", givenTree, nucTree); ClearConstraints		(givenTree);LikelihoodFunction 		lf = (filteredData,givenTree);matingChoice = 0;reprFlag	 = 0;currentPopulation  = {};USE_LAST_RESULTS=1;if (verboseFlag){	VERBOSITY_LEVEL 				= 1;}/*if (filteredData.species > 10 && filteredData.unique_sites/(MPI_NODE_COUNT) > 10){	AUTO_PARALLELIZE_OPTIMIZE		= 1;}*/global NSR0 = 1;ReplicateConstraint ("this1.?.nonSynRate:=NSR0*this2.?.synRate", givenTree, givenTree);Optimize (res,lf);fprintf					("checkpoint.log", CLEAR_FILE, lf);AUTO_PARALLELIZE_OPTIMIZE = 0;currentBLEstimates   = BranchLength (givenTree,-1)*3;VERBOSITY_LEVEL  = 0;USE_LAST_RESULTS = 0;baseParams 		   = res[1][1]+9;fprintf (progressFilePath,CLEAR_FILE, "<DIV CLASS='RepClassSM'>\nBase model has ", baseParams, " parameters. Log-L = ",res[1][0] ,". Mean dN/dS = ", NSR0, "</DIV>");crapAIC			   = -2*(res[1][0]-baseParams*sampleCount/(sampleCount-baseParams-1));sortedScores	   = {populationSize,2};sortedScores[0][0] = -crapAIC;sortedScores[0][1] = 0;currentPopulation [0] = {stateVectorDimension,1};AC:=AC__;AT:=AT__;CG:=CG__;CT:=CT__;GT:=GT__;/* INCLUDE THE CHC CORE */ibfPath = "GA_CHC.ibf";byBPImprovement		  = {};byBPImprovement[1]    = crapAIC;bestIndividualOverall = sortedScores[0][0];currentBEST_IC		  = crapAIC;byBPRates			  = {};byBPRates[1]          = {};(byBPRates[1])["NSR0"]= NSR0;byBPIndividual		  = {};maxRateClasses		  = Min(maxRateClasses,stateVectorDimension);ExportAMatrix2 (detailedResultPath,currentPopulation[0],crapAIC,byBPRates[1]);current_BPP_done_counter = 1;individual = 0;for (currentBPC = startWithRateClasses; currentBPC < maxRateClasses; currentBPC = currentBPC + 1){	rateClassesCount 		= currentBPC;	fprintf (progressFilePath, "<DIV CLASS='RepClassSM'>\nStarting the GA with ", currentBPC, " rate classes.</DIV>");	addOnLine = " with " + rateClassesCount + " rate classes.";		totalModelCounter = StirlingN(stateVectorDimension,currentBPC);	if (currentBPC > startWithRateClasses)	{		children = {};		individual = 0;				for (individual=populationSize $ 2; individual<populationSize-1; individual=individual+1)		{			cString    = currentPopulation[populationSize-1];			toggleRate = Random (0,stateVectorDimension-0.00001)$1;			cString [toggleRate] = currentBPC-1;			cString 						= MakeStringCanonical(cString,rateClassesCount);			cString							= IsChildViable (cString);			sortedScores[individual][1] 	= individual;			currentPopulation[individual] 	= cString;			RunASample (compressedString[rateClassesCount-1],individual);		}	}			mutationProb = 0.15;	ExecuteAFile (ibfPath);		kf						 = -sortedScores[populationSize-1][0];		byBPIndividual  [currentBPC] = currentPopulation[populationSize-1];	if (currentBEST_IC > kf)	{		currentBEST_IC 				 = kf;		byBPRates[currentBPC]   	 = RatesList[MatrixToString(currentPopulation[populationSize-1])];		byBPImprovement [currentBPC] = currentBEST_IC; 	}	else	{		break;	}	current_BPP_done_counter = Abs(MasterList);	}/* try a consensus matrix */fprintf (detailedResultPath, CLOSE_FILE);fprintf (progressFilePath,CLEAR_FILE,"DONE");GetString 			(HTML_OUT, TIME_STAMP, 1);fprintf 			("usage.log",HTML_OUT[0][Abs(HTML_OUT)-2],",",ds_0.species,",",ds_0.sites/3,",",Time(1)-timer,",",_in_ModelDescription,",",currentBPC-1,"\n");/*---------------------------------------------------------------------------------------------------------------------------------------------*//*---------------------------------------------------------------------------------------------------------------------------------------------*/function 	spoolAICTable (dummy){	colorList 	= {{"red","black","blue","green","purple","orange"}};	fcolorList 	= {{"white","white","white","white","white","black"}};	htmlAICTable = "";	htmlAICTable * 128;	htmlAICTable * "<div style = 'width: 580px; border: black solid 1px; '>";	htmlAICTable * "<table style = 'width: 100%;font-size: 10px;text-align:left;'><tr><th>Rates</th><th>c-AIC</th><th>&Delta; c-AIC</th><th width = '70%'>dN/dS by class (#branches)</th></tr>";	currentAIC = byBPImprovement [1];	for (_partCount = 1; _partCount <=Abs (byBPImprovement); _partCount = _partCount + 1)	{		bpLocs2    = byBPRates		 [_partCount];		bpLocs3    = byBPIndividual  [_partCount];				if (_partCount>1)		{			currentAIC = byBPImprovement [_partCount];			ci 		   = byBPImprovement [_partCount-1] - currentAIC;			sp		   = "<table style = 'padding: 0px; spacing: 0px;'><tr>";						byClassC   = {};			for (k=0; k<stateVectorDimension; k=k+1)			{				byClassC[bpLocs3[k]] = byClassC[bpLocs3[k]] + 1;			}						for (k=0; k<Abs (bpLocs2); k=k+1)			{				sp = sp + "<td style = 'font-size:10px;'>" + bpLocs2["NSR"+k] + " (" + byClassC [k] +")</td>";			}				sp = sp + "</tr></table>";		}		else		{			ci 		   = "";			sp		   = "<table><tr><td style = 'font-size:10px;width: 406px;'>"+bpLocs2["NSR0"]+" ("+stateVectorDimension+")</td></tr></table>";		}		htmlAICTable * ("\n<tr><td>"+ _partCount+ 							  "</td><td><div style = 'width: "+100*currentAIC/byBPImprovement [1]$1+"%; background-color: purple; color: white;'>"+currentAIC+ 							  "</div></td><td>"+ ci+ 							  "</td><td>"+ sp+							  "</td></tr>");			}	htmlAICTable * "\n</table></div>";	htmlAICTable * 0;	return htmlAICTable;}/*---------------------------------------------------------------------------------------------------------------------------------------------*/function StirlingN (objects, bins){	sno      = 0;	fact     = {bins+1,1};	fact [0] = 1;	for (_k=1; _k<=bins; _k = _k+1)	{		fact[_k] = _k*fact[_k-1];	}		toggle = (-1)^(bins-1);	for (_k=1; _k<=bins; _k = _k+1)	{		sno = sno + (toggle)*fact[bins]/fact[_k]/fact[bins-_k]*_k^objects;		toggle = -toggle;	}	return sno/fact[bins];}