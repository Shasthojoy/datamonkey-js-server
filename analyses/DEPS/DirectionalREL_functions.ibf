/*--------------------------------------------------------------------------------------------*/
/*	
	returns stationary distribution vector for amino acids
	UNUSED?!?
*/
function GetEqFreqs (ModelMatrixName&, baseFreqs)
{
	t = 1;
	
	/* duplicate instantaneous rate parameterization from template  model */
	numRateMx = ModelMatrixName;
	
	for (ri = 0; ri < 20; ri = ri+1)
	{
		for (ci = 0; ci < 20; ci = ci+1)
		{
			if (ri != ci)
			{
				/* multiply entries by base frequencies */
				numRateMx[ri][ci] = numRateMx[ri][ci] * baseFreqs[ci];
				
				/* diagonal entry is sum of off-diagonal row entries (Markov process) */
				numRateMx[ri][ri] = numRateMx[ri][ri] - numRateMx[ri][ci];
			}
		}
	}
	
	
	for (ri = 0; ri < 20; ri = ri+1)
	{
		numRateMx [ri][19] = 1;
	}
	numRateMxI = Inverse (numRateMx);
	return numRateMxI [19][-1];
}

/*--------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------*/
/* 
	Compute the difference vector between the stationary distribution at the root (efv) and the expected
	distribution of residues after time t0.
*/
function computeDelta (ModelMatrixName&, efv, t_0, which_cat)
{
	t   	= t_0;
	c   	= 1;
	catVar  = which_cat;
	rmx 	= ModelMatrixName;
	for (r=0; r<20; r=r+1)
	{	
		diag = 0;
		for (c=0; c<20; c=c+1)
		{
			rmx[r][c] = rmx[r][c] * efv[c];
			diag = diag - rmx[r][c];
		}
		rmx[r][r] = diag;
	}
	return Transpose(efv)*(Exp (rmx) - {20,20}["_MATRIX_ELEMENT_ROW_==_MATRIX_ELEMENT_COLUMN_"]);
}

/*------------------------------------------------------------------------------*/

function SendAJob (residueIn)
{
	for (nodeID = 0; nodeID < MPI_NODE_COUNT -1; nodeID = nodeID + 1)
	{
		if (MPINodeStatus[nodeID] < 0)	/* semaphore indicates available node */
		{
			MPINodeStatus[nodeID] = residueIn;
			MPISend (nodeID+1,lfb);
			break;
		}
	}
	if (nodeID == MPI_NODE_COUNT - 1)	/* looped through semaphore with no idle nodes */
	{
		MPIReceive (-1, fromNode, theJob);	/* wait until one of the node completes its job */
		oldRes = MPINodeStatus[fromNode-1];
		MPISend (fromNode,lfb);
		MPINodeStatus[fromNode-1] = residueIn;
		ExecuteCommands (theJob);	/* load serialized LF into master node memory */
		DoResults (oldRes);
	}
	return 0;
}

/*------------------------------------------------------------------------------*/

function DoResults (residueIn)
{
	residueC 					= 	AAString[residueIn];
	

	/*fprintf							(intermediateHTML, "<TR><TD>",residueC,"</TD>"); */
	fprintf							(summaryPath, "[PHASE ",residueIn+1,".1] Model biased for ",residueC,"\n"); 

	pv							=   1-CChi2(2(lfb_MLES[1][0]-baselineLogL),3);	/* approximate p-value */
	
	
	/*fprintf							(intermediateHTML, "<TD>",Format(lfb_MLES[1][0],8,3),"</TD>"); */
	fprintf							(summaryPath, "[PHASE ",residueIn+1,".2] Finished with the model biased for ",residueC,". Log-L = ",Format(lfb_MLES[1][0],8,3),"\n"); 
	
	fr1 						= 	P_bias;
	
	rateAccel1					=   (computeDelta("biasedMatrix",vectorOfFrequencies,referenceL,1))[residueIn];
	
	/*fprintf							(intermediateHTML, "<TD>", Format(rateBiasTo,8,3),
											 "</TD><TD>", Format(fr1,8,3),
											 "</TD><TD>", Format(rateAccel1*100,8,3),
											 "</TD><TD>", Format(pv,8,3),"</TD>");*/
											 
	fprintf							(summaryPath, "\n\tBias term           = ", Format(rateBiasTo,8,3),
											 	  "\n\tproportion          = ", Format(fr1,8,3),
											      "\n\tExp freq increase   = ", Format(rateAccel1*100,8,3), "%",
											      "\n\tp-value    = ", Format(pv,8,3),"\n");
									      
									      
	if ( pv < 0.0025 ) {
		fprintf ( intermediateHTML, "<DIV class = 'RepClassSM'>Residue ", residueC, " shows evidence of directional selection; Bias term = ", Format(rateBiasTo,8,3), "; Proportion of affected sites = ", Format(fr1,8,3), "; Expected frequency increase = ", Format(rateAccel1*100,8,3), "; P-value = ", Format(pv,8,3), "</DIV>");
		
	}
	/*fprintf							(intermediateHTML, "</TR>"); 		*/								   
	
	LIKELIHOOD_FUNCTION_OUTPUT = 7;
	outPath = baseFilePath + "." + residueC;
	fprintf (outPath, CLEAR_FILE, lfb);
	
	byResidueSummary [residueC] = {};
	(byResidueSummary [residueC])["p"] = pv;		

	test_p_values [residueIn][0] = pv;
	test_p_values [residueIn][1] = residueIn;
	
	/*if (pv < 0.0025)*/
	{
		(byResidueSummary [residueC])["sites"] = {};		
		(byResidueSummary [residueC])["BFs"]   = {};		
		
		ConstructCategoryMatrix (mmx,lfb,COMPLETE);
		GetInformation			(catOrder, lfb);		
		dim = Columns (mmx);
		_MARGINAL_MATRIX_	= {2, dim};
		
		GetInformation 				(cInfo, c);
		GetInformation 				(_CATEGORY_VARIABLE_CDF_, catVar);
		
		ccc	= Columns (cInfo);
		
		_CATEGORY_VARIABLE_CDF_ = _CATEGORY_VARIABLE_CDF_[1][-1];
		if (catOrder [0] == "c")
		{
			for (k=0; k<dim; k=k+1)
			{
				for (k2 = 0; k2 < ccc; k2=k2+1)
				{
					_MARGINAL_MATRIX_ [0][k] = _MARGINAL_MATRIX_ [0][k] + mmx[2*k2][k]  *cInfo[1][k2];
					_MARGINAL_MATRIX_ [1][k] = _MARGINAL_MATRIX_ [1][k] + mmx[2*k2+1][k]*cInfo[1][k2];
				}
			}
		}
		else
		{
			for (k=0; k<dim; k=k+1)
			{
				for (k2 = 0; k2 < ccc; k2=k2+1)
				{
					_MARGINAL_MATRIX_ [0][k] = _MARGINAL_MATRIX_ [0][k] + mmx[k2][k]*cInfo[1][k2];
					_MARGINAL_MATRIX_ [1][k] = _MARGINAL_MATRIX_ [1][k] + mmx[ccc+k2][k]*cInfo[1][k2];
				}
			}
		}
		ExecuteAFile 					(HYPHY_LIB_DIRECTORY + "ChartAddIns" + DIRECTORY_SEPARATOR + "DistributionAddIns" + DIRECTORY_SEPARATOR + "Includes" + DIRECTORY_SEPARATOR + "posteriors.ibf");
		
		prior = (_CATEGORY_VARIABLE_CDF_[1])/(1-_CATEGORY_VARIABLE_CDF_[1]);
				
		for (k=0; k<dim; k=k+1)
		{
			bayesF = _MARGINAL_MATRIX_[1][k]/_MARGINAL_MATRIX_[0][k]/prior;
			((byResidueSummary [residueC])["BFs"])[k] = bayesF;
			if (bayesF > 100)
			{
				((byResidueSummary [residueC])["sites"])[Abs((byResidueSummary [residueC])["sites"])] = k+1;
				if (Abs(bySiteSummary[k]) == 0)
				{
					bySiteSummary[k] = {};
				}
				(bySiteSummary[k])[Abs(bySiteSummary[k])] = residueC;
			}
		}
		
	}	
	
	return 0;
}
