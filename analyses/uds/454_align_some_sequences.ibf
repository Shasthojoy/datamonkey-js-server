// needs 
//      - masterReferenceSequence
//      - sequences2align , in the form of ["seqid"] = "nuc sequence"
//      - homExp; expected per base homology score

result_AVL    = {};

inStr		  = {{masterReferenceSequence,""}};

seqNames = Rows(sequences2align);
seqs2alignCount = Abs(sequences2align);
for (seqCounter = 0; seqCounter < seqs2alignCount; seqCounter += 1)
{
    aSeq = sequences2align[seqNames[seqCounter]];
    
    rcSeq       = RevComp (aSeq);
    _uds_seqlen = Abs( aSeq ) / 3;
    
    inStr[1] = aSeq;
    AlignSequences ( direct_score, inStr, _cdnaln_alnopts );
    direct_score = direct_score [0];
    
    inStr[1] = rcSeq;
    AlignSequences ( rc_score, inStr, _cdnaln_alnopts );
    rc_score = rc_score[0];
    
    if (rc_score [0] > direct_score[0]) {
        rc     = 1;
        bestAl = rc_score;
        bestScorePerBase = rc_score[0];
    } else {
        rc = 0;
        bestAl = direct_score;
        bestScorePerBase = direct_score[0];
    }
    
    if (_uds_seqlen) {
        bestScorePerBase = bestScorePerBase / _uds_seqlen;
    } else {
        bestScorePerBase = -1000;
    }
    
    
    
    if (_uds_seqlen > 0 && bestScorePerBase>homExp) {
        alL = computeCorrection(bestAl[1]);
        /*alL is the starting,ending nucleotide on the reference relative to the read. if reference is longer than the read, then both are 0*/
        offsetFrom = (bestAl[2]$"^\\-+")[1]+1;
        
        shifter_start = 1*(offsetFrom>0);
        while (shifter_start < offsetFrom) {
             if (((bestAl[1])[offsetFrom-shifter_start]$"[acgt]")[0]<0) {
                shifter_start = shifter_start - 1;
                break;
             }
             shifter_start += 1;
        }
        offsetFrom = offsetFrom - shifter_start;
        offsetTo   = (bestAl[2]$"\\-+$")[0]-1;
        
        if (offsetTo < 0) {
            offsetTo = Abs(bestAl[2])-1; /*if no trailing indels then to end of read*/
        } else {
            shifter_start = 1;
            upto = Abs(bestAl[1])-offsetFrom;
            while (shifter_start < upto) {
                 if (((bestAl[1])[offsetTo+shifter_start]$"[acgt]")[0]<0) {
                    shifter_start = shifter_start - 1;
                    break;
                 }
                 shifter_start += 1;
            }
            offsetTo += shifter_start;
        }

        
        seqOffset  = offsetFrom;          /*set the offset of the read relative to the reference. ie the number of indels needed on the read to align to the reference */
        offsetFrom +=  alL[0];           /*if the read starts before the reference then shift to start of reference ie. by alL[0] */
        offsetTo    =  offsetTo	- alL[1];           /*if the read extends beyond the reference then shift to end of reference ie. by alL[1] */
        
        theSeq     = bestAl[2];
        theSeq	   = theSeq[alL[0]][Abs(theSeq)-alL[1]-1]; /*the nucleotide sequence of the read that overlaps with the reference sequence */
        
        
        nucSeq	   = (bestAl[2])[offsetFrom][offsetTo]; /*read sequence pruned to exactly overlapping region*/
        nucSeqRef  = (bestAl[1])[offsetFrom][offsetTo]; /*reference sequence pruned to exactly overlapping region*/
        
        cleaned_up = _cdn_alignment_cleanup (nucSeqRef, nucSeq,seqOffset);
        //fprintf (stdout, "\n", cleaned_up["REF"], "\n", cleaned_up["QRY"], "\n\n");
        
        if (izpass2) {
            result_AVL [seqNames[seqCounter]] = {"OFFSET_PASS2"          : seqOffset + 1,
                                                "SPAN_PASS2"            : cleaned_up["SPAN"],
                                                "SCORE_PASS2"           : bestScorePerBase,
                                                "NUC_PASS2"             : cleaned_up["QRY"],
                                                "REF_PASS2"             : cleaned_up["REF"],
                                                "STAGE"  : 2};
                                                
            //fprintf (stdout, result_AVL [seqNames[seqCounter]], "\n");
        
        } else {        
            result_AVL [seqNames[seqCounter]] = {"ALIGNED"              : cleaned_up["QRY"],
                                                "OFFSET_NUC"            : seqOffset,
                                                "ALIGNED_AA"            : cleaned_up ["AA"],
                                                "ALIGNED_AA_REF"        : cleaned_up ["AA_REF"],
                                                "OFFSET"                : cleaned_up ["OFFSET_AA"] + 1, // reindexed to be base 1
                                                "SPAN"                  : cleaned_up["SPAN"],
                                                "RC"                    : rc,
                                                "SCORE"                 : bestScorePerBase,
                                                "TOOLONG"               : cleaned_up["TOO_LONG"],
                                                "TOOSHORT"              : cleaned_up["TOO_SHORT"],
                                                "ALIGNED_NOTCLEAN"      : nucSeq,
                                                "ALIGNED_NOTCLEAN_REF"  : nucSeqRef,
                                                "STAGE"  : 1};
        }
                                            
        
    }
    else
    {
        result_AVL [seqNames[seqCounter]] = {"STAGE": "3", "SCORE"                 : bestScorePerBase};
    }
    //SetParameter (STATUS_BAR_STATUS_STRING, "Alignment to reference pass 1 ("+seqCounter+"/"+seqs2alignCount+" done)",0);
}

return result_AVL;
