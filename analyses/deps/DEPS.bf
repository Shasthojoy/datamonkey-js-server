/*INPUT:	_in_FilePath			: upload.numbers.1	_in_GeneticCodeTable	: -2 for a protein alignment (Directional REL only on protein alignments)	_in_ProteinModel		: string descriptor (see Shared/ProteinModels/modellist.ibf)	_in_rvChoice			: option for rate variation	_in_rateClasses			: rate variation classes	_in_treeMode			: tree used for analysis (uploaded or nj)	_in_fixRoot				: taxon to root tree on for directional model	*/#include "DirectionalREL_functions.ibf";timer = Time(1);RequireVersion  ("0.9920060815");fscanf  			(stdin,"String",_in_FilePath);fscanf				(stdin,"Number",_in_GeneticCodeTable);fscanf  			(stdin,"String",_in_ProteinModel);fscanf				(stdin,"Number",_in_rvChoice);fscanf              (stdin,"Number",_in_rateClasses);fscanf				(stdin,"Number",_in_treeMode);fscanf				(stdin,"String",_in_fixRoot);rateClasses = _in_rateClasses;ExecuteAFile			("../Shared/globals.ibf");ExecuteAFile			("../Shared/GrabBag.bf");ExecuteAFile			("AddABias.ibf");ExecuteAFile 			("../Shared/AncestralMapper.bf");ExecuteAFile			("../Shared/ProteinModels/modellist.ibf");ExecuteAFile			("../Shared/ReadDelimitedFiles.bf");GetURL 				(dataFileString,BASE_URL_PREFIX+MANGLED_PREFIX+"/"+_in_FilePath);GetURL              (analysisSpecRaw, _getTreeLink (_in_FilePath,_in_treeMode,_in_fixRoot));baseFilePath  		= "spool/"+_in_FilePath;intermediateHTML	= baseFilePath + ".progress";finalPHP			= baseFilePath + ".out";fprintf				(finalPHP,   CLEAR_FILE, KEEP_OPEN);fprintf				(intermediateHTML, CLEAR_FILE, "<DIV class = 'RepClassSM'><b>DIRECTIONAL EVOLUTION IN PROTEIN SEQUENCES</b></DIV>");dataType					= (_in_GeneticCodeTable==(-2));reportModelString   		= _generateModelName (dataType, _in_ProteinModel,_in_rvChoice,"modelDescString");longModelName 				= _getLongModelName (_in_ProteinModel);modelNameString				= "_customAAModelMatrix";/*fprintf ( finalPHP, _in_FilePath, "\n", _in_GeneticCodeTable, "\n", _in_ProteinModel, "\n", _in_rvChoice, "\n", _in_rateClasses, "\n", _in_treeMode, "\n", _in_fixRoot, "\n" );*/empAAPath 					= HYPHY_LIB_DIRECTORY + "TemplateBatchFiles" + DIRECTORY_SEPARATOR + "TemplateModels" + DIRECTORY_SEPARATOR + "EmpiricalAA" +  DIRECTORY_SEPARATOR + _in_ProteinModel;modelPath 					= HYPHY_LIB_DIRECTORY + "TemplateBatchFiles" + DIRECTORY_SEPARATOR + "TemplateModels" + DIRECTORY_SEPARATOR + "Custom_AA_empirical.mdl";ExecuteAFile			("../Shared/_MFReaderUniversal_.ibf");modelSTDINoverload = {};modelSTDINoverload["0"] = "" + empAAPath;modelSTDINoverload["1"] = "ML Estimates";modelSTDINoverload["2"] = "Rate variation";if ( _in_rvChoice == 1 ) {	modelSTDINoverload["3"] = "General Discrete";}else {	modelSTDINoverload["3"] = "Beta-Gamma";}modelSTDINoverload["4"] = "" + _in_rateClasses;ExecuteAFile (modelPath,modelSTDINoverload);VERBOSITY_LEVEL		= -1;/* define an associative array with key = amino acid and value = integer	index for AA in alphabetical order */AAString    = "ACDEFGHIKLMNPQRSTVWY";AACharToIdx = {};		/* this is never used :-P */for (k=0; k<20; k=k+1){	AACharToIdx [AAString[k]] = k;}test_p_values = {20,2};SKIP_MODEL_PARAMETER_LIST	= 0;ACCEPT_ROOTED_TREES			= 1;/* check if the tree is rooted */populateTrees ("givenTree", 1);treeString = RerootTree ( givenTree_1, _in_fixRoot);Tree givenTree = treeString;treeAVL  = givenTree^0;rootNode = treeAVL[(treeAVL[0])["Root"]];if (Abs(rootNode["Children"]) != 2){	fprintf (stdout, "ERROR: please ensure that the tree is rooted");	return 0;}root_left  = "givenTree." + (treeAVL[(rootNode["Children"])[0]])["Name"] + ".t";root_right = "givenTree." + (treeAVL[(rootNode["Children"])[1]])["Name"] + ".t";if (Abs(_in_fixRoot)){	/* branch to first sequence is collapsed to length zero;	 enforcing identifiability with root sequence */	ExecuteCommands ("givenTree."+TipName(givenTree,0)+".t:=0");}else{	return 0;}/* only the sum of branch lengths leading to two immediate descendants of root can be estimated; this measure prevents one of the branches from collapsing to zero length */ExecuteCommands					(root_left + ":=" + root_right); LikelihoodFunction lf 		= 	(filteredData, givenTree);fprintf							(intermediateHTML, "<DIV class = 'RepClassSM'><b>Phase 1</b> Standard model fit</DIV>\n"); VERBOSITY_LEVEL				= 0;AUTO_PARALLELIZE_OPTIMIZE	= 1;Optimize 					(res_base,lf);AUTO_PARALLELIZE_OPTIMIZE	= 0;VERBOSITY_LEVEL				= -1;/* export baseline model LF */LIKELIHOOD_FUNCTION_OUTPUT = 7;outPath = baseFilePath + ".base";fprintf (outPath, CLEAR_FILE, lf);baselineLogL				= res_base[1][0];/* when the heck does biasedTree get called?  It's tucked inside runAFit() in AddABias.ibf... */root_left  = "biasedTree." + (treeAVL[(rootNode["Children"])[0]])["Name"] + ".t";root_right = "biasedTree." + (treeAVL[(rootNode["Children"])[1]])["Name"] + ".t";/* vector of branch lengths for entire tree */baselineBL						= BranchLength (givenTree,-1);referenceL						= (baselineBL * (Transpose(baselineBL)["1"]))[0];summaryPath					   = baseFilePath+".summary";substitutionsPath			   = baseFilePath+"_subs.csv";siteReportMap				   = baseFilePath+"_bysite.csv";fprintf 						(summaryPath, CLEAR_FILE, KEEP_OPEN);fprintf							(intermediateHTML, "\n<DIV class = 'RepClassSM'><b>Phase 1</b> Baseline model fit. Log-L = ",baselineLogL,". Tree length = ",referenceL, " subs/site</DIV>"); fprintf							(summaryPath, "[PHASE 0.2] Standard model fit. Log-L = ",baselineLogL,". Tree length = ",referenceL, " subs/site \n"); fixGlobalParameters ("lf");byResidueSummary = {};bySiteSummary	 = {};/*------------------------------------------------------------------------------*/if (MPI_NODE_COUNT > 1){	MPINodeStatus = {MPI_NODE_COUNT-1,1}["-1"];}fprintf ( intermediateHTML, "<DIV class = 'RepClassSM'><b>Phase 2</b> Testing each residue for directional selection</DIV>" );/*fprintf ( intermediateHTML, "<DIV class = 'RepClassSM'><TABLE BORDER = '0' cellspacing = '1px' cellpadding = '5px' style = 'padding:10px><TR><TD>RESIDUE</TD><TD>LOG LK</TD><TD>BIAS</TD><TD>PROPORTION</TD><TD>EXP FREQ INCREASE</TD><TD>P-VALUE</TD></TR>" );*/for (residue = 0; residue < 20; residue = residue + 1){		/*fprintf ( intermediateHTML, "<DIV class = 'RepClassSM'>Testing", AAString[residue] ,"for directional selection</DIV>" );*/		AddABiasREL 					(modelNameString,"biasedMatrix",residue);	/* returns biasedMatrix object */		global P_bias2 					:= 1;		global relBias					:= 1;				/* vectorOfFrequencies comes from Custom_AA_empirical.mdl, in turn imported from a file such as "HIVWithin" */		/* rate matrix is multiplied by this vector (third argument) */		Model							biasedModel = (biasedMatrix, vectorOfFrequencies, 1);		Tree							biasedTree = treeString;		global							treeScaler = 1;				/* constrains tree to be congruent to that estimated under baseline model */		ReplicateConstraint 			("this1.?.?:=treeScaler*this2.?.?__",biasedTree,givenTree);		ExecuteCommands					(root_left + "=" + root_left);		ExecuteCommands					(root_right + "=" + root_right);		LikelihoodFunction lfb 		= 	(filteredData, biasedTree);						if (MPI_NODE_COUNT > 1)		{			SendAJob (residue);		}		else		{			Optimize 						(lfb_MLES,lfb);			DoResults 						(residue);		}	}/*fprintf ( intermediateHTML, "</TABLE></DIV>" );*//*------------------------------------------------------------------------------*/if (MPI_NODE_COUNT > 1){	jobsLeft = ({1,MPI_NODE_COUNT-1}["1"] * MPINodeStatus["_MATRIX_ELEMENT_VALUE_>=0"])[0];	for (nodeID = 0; nodeID < jobsLeft; nodeID = nodeID + 1)	{		MPIReceive (-1, fromNode, theJob);		oldRes = MPINodeStatus[fromNode-1];		ExecuteCommands (theJob);		DoResults (oldRes);		}}/*------------------------------------------------------------------------------*/fprintf							(substitutionsPath, CLEAR_FILE, KEEP_OPEN, "Site,From,To,Count");fprintf							(siteReportMap,     CLEAR_FILE, KEEP_OPEN, "Site");for (k=0; k<20; k=k+1){	fprintf (siteReportMap, ",", AAString[k]);}fprintf (siteReportMap, "\nLRT p-value"); test_p_values       = test_p_values % 0;rejectedHypotheses   = {};for (k=0; k<20; k=k+1){	pv      = (byResidueSummary[AAString[k]])["p"];	fprintf (siteReportMap, ",", pv);}fprintf (summaryPath, "\nResidues (and p-values) for which there is evidence of directional selection");countResidues = 0;for (k=0; k<20; k=k+1){	if (test_p_values[k][0] < (0.05/(20-k)))	{		rejectedHypotheses  [test_p_values[k][1]]           = 1;		rejectedHypotheses  [AAString[test_p_values[k][1]]] = 1;		/*fprintf (intermediateHTML, 		"\n\t", AAString[test_p_values[k][1]], " : ",test_p_values[k][0] );*/		fprintf (summaryPath, 	"\n\t", AAString[test_p_values[k][1]], " : ",test_p_values[k][0] );		countResidues = countResidues + 1;	}	else	{		break;	}}fprintf (summaryPath, "\n");ancCacheID 						= _buildAncestralCache ("lf", 0);outputcount						= 0;for (k=0; k<filteredData.sites; k=k+1){	thisSite = _substitutionsBySite (ancCacheID,k);		for (char1 = 0; char1 < 20; char1 = char1+1)	{		for (char2 = 0; char2 < 20; char2 = char2+1)		{			if (char1 != char2 && (thisSite["COUNTS"])[char1][char2])			{					ccount = (thisSite["COUNTS"])[char1][char2];				fprintf (substitutionsPath, "\n", k+1, ",", AAString[char1], ",", AAString[char2], "," , ccount);			}		}	}		if (Abs(bySiteSummary[k]))	{		fprintf (siteReportMap, "\n", k+1);				didSomething = 0;		pv			 = 0;		for (k2=0; k2<20; k2=k2+1)		{			if (Abs((byResidueSummary[AAString[k2]])["BFs"]) == 0 || rejectedHypotheses[k2] == 0)			{				fprintf (siteReportMap, ",N/A");			}			else			{				thisSitePV = ((byResidueSummary[AAString[k2]])["BFs"])[k];				pv = Max(pv,thisSitePV);				fprintf (siteReportMap, ",", thisSitePV);							if (pv > 100)				{					didSomething = 1;				}			}		}				if (!didSomething)		{			continue;		}				if (outputcount == 0)		{			outputcount = 1;			fprintf (summaryPath, 	"\nThe list of sites which show evidence of directional selection (Bayes Factor > 20)\n",							 		"together with the target residues and inferred substitution counts\n");		}			fprintf (summaryPath, "\nSite ", Format (k+1,8,0), " (max BF = ", pv, ")\n Preferred residues: ");						for (k2 = 0; k2 < Abs (bySiteSummary[k]); k2=k2+1)		{			thisChar = (bySiteSummary[k])[k2];			if (rejectedHypotheses[thisChar])			{				/*fprintf (intermediateHTML,      thisChar);*/				fprintf (summaryPath, thisChar);			}		}		fprintf (summaryPath,      "\n Substitution counts:");		for (char1 = 0; char1 < 20; char1 = char1+1)		{			for (char2 = char1+1; char2 < 20; char2 = char2+1)			{				ccount  = (thisSite["COUNTS"])[char1][char2];				ccount2 = (thisSite["COUNTS"])[char2][char1];				if (ccount+ccount2)				{						fprintf (summaryPath, "\n\t", AAString[char1], "->", AAString[char2], ":", Format (ccount, 5, 0), "/",											 AAString[char2], "->", AAString[char1], ":", Format (ccount2, 5, 0));				}			}		}	}}	fprintf ( finalPHP, _in_ProteinModel, "\n", longModelName, "\n", _in_rvChoice, "\n", _in_rateClasses, "\n", _in_treeMode, "\n", _in_fixRoot, "\n" );_destroyAncestralCache 			(ancCacheID);fprintf (substitutionsPath, CLOSE_FILE);fprintf (summaryPath, 		CLOSE_FILE);fprintf (siteReportMap, 	CLOSE_FILE);fprintf (finalPHP,			CLOSE_FILE);fprintf (intermediateHTML,CLEAR_FILE,"DONE");GetString (HTML_OUT, TIME_STAMP, 1);fprintf ("usage.log",HTML_OUT[0][Abs(HTML_OUT)-2],",",filteredData.species,",",filteredData.sites,",",Time(1)-timer,",",_in_ProteinModel,",",countResidues,"\n");