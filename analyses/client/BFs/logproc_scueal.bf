ExecuteAFile ("../Shared/HyPhyGlobals.ibf");ExecuteAFile ("../Shared/ReadDelimitedFiles.bf");fscanf (stdin, "String", logFilePath);fscanf (stdin, "String", pvalString);fscanf (stdin, "String", method);fscanf (logFilePath,"Raw",logFile);sscanf (logFile,"String",aLine);/*------------------------------------------------------------------------------------*/function MakeStringCanonical (modelString){	charOccurrences = {};	for (s2 = 0; s2 < Abs (modelString); s2 = s2 + 1)	{		c = modelString[s2];		if (charOccurrences[c] == 0)		{			charOccurrences [c] = Abs(charOccurrences)+1;		}	}	modString = "";	for (s2 = 0; s2 < Abs (modelString); s2 = s2 + 1)	{		c = modelString[s2];		c = charOccurrences[c];		modString = modString + (c-1);	}	return modString;}/*------------------------------------------------------------------------------------*/function secondsSinceJan1_2004 (timeString){	parsedTime = timeString || "( |\\:)+";	ps1 = parsedTime[0]+1;	ps2 = parsedTime[2]-1;	mon = timeString[ps1][ps2];	mon = months[mon];	ps1 = parsedTime[4]-1;	day = 0+timeString[ps2+2][ps1];	ps2 = parsedTime[6]-1;	hr  = 0+timeString[ps1+2][ps2];	ps1 = parsedTime[8]-1;	min = 0+timeString[ps2+2][ps1];	ps2 = parsedTime[10]-1;	sec = 0+timeString[ps1+2][ps2];	yar = 0+timeString[ps2+2][Abs(parsedTime)-1];	parsedTime = ((((yar-2004)*365 + (yar-2001)$4 + monthsNum[1][mon] + day)*24 + hr)*60 + min)*60 +sec;	if (yar % 4 == 0 && mon > 1)	{		parsedTime = parsedTime + 24*3600;	}	return parsedTime;}/*------------------------------------------------------------------------------------*/function statOnMatrix (aMatrix, startIndex, doHist){	summaryStats = {};		itemCount 	 = Abs(aMatrix)-startIndex;	numMatrix	 = {itemCount,1};	oneMatrix	 = {1,itemCount};		nonNegs = 0;	for (ii = 0; ii < itemCount; ii = ii+1)	{		numMatrix[ii] = aMatrix[startIndex+ii];		oneMatrix[ii] = 1;		if (numMatrix[ii] >= 0)		{			nonNegs = nonNegs + 1;		}	}		if (nonNegs < itemCount)	{		numMatrix	 = {nonNegs,1};		oneMatrix	 = {1,nonNegs};				ii2 = 0;		for (ii = 0; ii < itemCount; ii = ii+1)		{			if (aMatrix[startIndex+ii] >= 0)			{				numMatrix[ii2] = aMatrix[startIndex+ii];				oneMatrix[ii2] = 1;				ii2 = ii2 + 1;			}		}		itemCount = nonNegs;	}		numMatrix = numMatrix % 0;	summaryStats ["Min"] = numMatrix[0];	summaryStats ["Max"] = numMatrix[itemCount-1];		oneMatrix = oneMatrix * numMatrix;	summaryStats ["Mean"]   = oneMatrix[0]/itemCount;	if (itemCount % 2)	{		summaryStats ["Median"] = numMatrix[itemCount$2];	}	else	{		summaryStats ["Median"] = 0.5*(numMatrix[itemCount$2]+numMatrix[itemCount$2-1]);	}		return summaryStats;}/*------------------------------------------------------------------------------------*/function nFormat (n){	if (n$1 == n)	{		return ""+n;	}	return Format (n,8,2);}/*------------------------------------------------------------------------------------*/function addTableLine (startIndex, doHist, timeframe, title){	outputHTML * ("<TR class = 'HeaderClassSM' style = 'font-size:11px'>");	if (Abs(timeframe))	{		outputHTML * ("<TH>Last " + timeframe + " days</TH>");	}	else	{		timeframe = (currentTime - dates[0])$86400+1;		outputHTML * ("<TH>Lifetime ("+timeframe+" days)</TH>");			}	jobs = 0;	if (startIndex >= 0)	{		jobs = Abs(dates)-startIndex;				outputHTML * (class1+jobs+"</TD>" +class1+ Format(jobs/timeframe,6,2)+ "</TD>");		ss = statOnMatrix (seqs,startIndex, doHist);				outputHTML * (class2+					  nFormat(ss["Mean"])+"</TD>"  +class2+					  nFormat(ss["Median"])+"</TD>"+class2+					  nFormat(ss["Min"]) + 					  "-" + nFormat(ss["Max"]) + "</TD>");					outputHTML * "</TR>\n";	}	else	{		outputHTML * ("<TD>0</TD><TD COLSPAN='9'></TD></TR>\n");		}		return {{jobs__,timeframe__}};}/*------------------------------------------------------------------------------------*/logEntries = {};dates  = {};seqs   = {};sites  = {};times  = {};parts  = {};models = {};months = {};months ["Jan"]=0;months ["Feb"]=1;months ["Mar"]=2;months ["Apr"]=3;months ["May"]=4;months ["Jun"]=5;months ["Jul"]=6;months ["Aug"]=7;months ["Sep"]=8;months ["Oct"]=9;months ["Nov"]=10;months ["Dec"]=11;monthsNum = {{31,28,31,30,31,30,31,31,30,31,30,31};			 {0,0,0,0,0,0,0,0,0,0,0,0}};			 for (idx = 1; idx < 12; idx = idx + 1){	monthsNum[1][idx] = monthsNum[1][idx-1]+monthsNum[0][idx-1];}idx = 0;GetString(currentTimeS,TIME_STAMP,1);class1	   = "<TD class = 'ModelClass1'>";class2	   = "<TD class = 'ModelClass2'>";outputHTML = "";outputHTML * 8192;outputHTML * ("<DIV class = 'RepClassSM'>"+method+" usage summary as of "+currentTimeS+"PST.<p>");outputHTML * "\n<TABLE style = 'font-size: 10px; font-family: times;' cellspacing = '1'>				<TR class = 'HeaderClassSM'><TH>Timeframe</TH>				<TH COLSPAN='2' align='center'>Analyses</TH>				<TH COLSPAN=3 align='center'>Sequences</TH>";				outputHTML * " <TR class = 'HeaderClassSM'><TH></TH><TH>Total</TH><TH>Per 24 hrs</TH><TH>Mean</TH><TH>Median</TH><TH>Range</TH></TR>\n";currentTime = secondsSinceJan1_2004 (currentTimeS);lastDay		= currentTime-86400;lastDIdx	= -1;lastWeek	= currentTime-7*86400;lastWIdx	= -1;lastMonth	= currentTime-30*86400;lastMIdx	= -1;countByClassification = {};totalProcessed = 0;while (!END_OF_FILE){	sscanf (logFile,"String",aLine);	if (Abs(aLine))	{		aLineT      = splitOnRegExp (aLine, "\\|");		fieldCount	= Abs (aLineT);		dates [idx] = secondsSinceJan1_2004(aLineT[0]);				if (lastMIdx < 0)		{			if (dates[idx] >= lastMonth)			{				lastMIdx = idx;			}		}		if (lastWIdx < 0)		{			if (dates[idx] >= lastWeek)			{				lastWIdx = idx;			}		}		if (lastDIdx < 0)		{			if (dates[idx] >= lastDay)			{				lastDIdx = idx;			}		}				processedSequences = 0;				for (z = 4; z < Abs (aLineT); z = z + 1)		{			components = splitOnRegExp (aLineT[z], "\\:");			if (components[0] != "0")			{				countByClassification [components[0]] = countByClassification [components[0]] + components[1];				processedSequences = processedSequences + components[1];			}		}		totalProcessed     = totalProcessed + processedSequences;				seqs[Abs(seqs)] = processedSequences;		idx = idx + 1;	}}addTableLine (lastDIdx,0,1,0);addTableLine (lastWIdx,0,7,0);stats1 = addTableLine (lastMIdx,0,30,0);stats2 = addTableLine (0,0,0,0);outputHTML * "\n</TABLE></DIV>";subtypeKinds = Rows (countByClassification);sortMx		 = {Abs (countByClassification), 2};for (k = 0; k < Abs (countByClassification); k = k+1){	sortMx [k][0] = k;	sortMx [k][1] = countByClassification[subtypeKinds[k]];}sortMx = sortMx % 1;outputHTML * ("\n<DIV CLASS = 'RepClassSM'><b>Top 10 Subtypes (out of " + totalProcessed + " sequences)</b><p>");				outputHTML * "\n<TABLE style = 'font-size: 12px; font-family: arial;' cellspacing = '1'>\n";outputHTML * "<TR class = 'HeaderClassSM'><TH>Subtypes</TH><TH>Times found</TH><TH>% found</TH></TR>\n";idx = Rows (sortMx);for (s = idx-1; s >= 0 && idx-s <=10 ; s = s-1){	if (s%2==0)	{		outputHTML * "<TR class = 'ModelClass1'>";	}	else	{		outputHTML * "<TR class = 'ModelClass2'>";	}	outputHTML * ("<TD>"+subtypeKinds[sortMx[s][0]]+"</TD><TD>"+sortMx[s][1]+"</TD><TD>"+ Format (sortMx[s][1]/totalProcessed*100,5,1)+"</TD></TR>\n");}outputHTML * "\n</TABLE></DIV>";outputHTML * 0;fprintf (stdout, outputHTML);fscanf 		 (LOG_SUMMARY_FILE, "NMatrix,NMatrix", lstats2, lstats1);stats1[0] 	= stats1[0] + lstats1[0];fprintf		 (LOG_SUMMARY_FILE, CLEAR_FILE, stats2+lstats2, stats1);	