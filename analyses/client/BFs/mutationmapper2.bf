ExecuteAFile("../Shared/HyPhyGlobals.ibf");ExecuteAFile("../Shared/GrabBag.bf");ExecuteAFile("../Shared/ReadDelimitedFiles.bf");fscanf		(stdin,"String", filePrefix);fscanf		(stdin,"String", rawSite);fscanf		(stdin,"Number", outputMode);siteInfo = splitOnRegExp (rawSite,"\\-");if (Abs (siteInfo) == 2){	contrastSites = 1;	siteIndex	  = 0 + siteInfo[0];	siteIndex2	  = 0 + siteInfo[1];}else{	contrastSites = 0;	siteIndex     = 0 + siteInfo[0];	if (rawSite[0] == "-")	{		siteIndex = -1;	}} residueMap =  	{{"Phe",					"Leu",					"Ile",					"Met",					"Val",					"Ser",					"Pro",					"Thr",					"Ala",					"Tyr",					"His",					"Gln",					"Asn",					"Lys",					"Asp",					"Glu",					"Cys",					"Trp",					"Arg",					"Gly",					"Mix"}};/* ________________________________________________________________________________________________*/function ErrorOut (errString){	fprintf (stdout, "ERROR:<DIV class = 'ErrorTagSM'>\n", errString, "\n</DIV>");	return 0;}/* ________________________________________________________________________________________________*/function MapCodeToAA (aaCode){	if (aaCode == 10)	{		return residueMap[20];	}	if (aaCode>10)	{		return residueMap[aaCode-1];	}	return residueMap[aaCode];}/* ________________________________________________________________________________________________*/ExecuteAFile	("../Shared/DBTools.ibf");ExecuteAFile	("../Shared/GrabBag.bf");slacDBID 		 = _openCacheDB      (filePrefix);generalInfo = _ExecuteSQL  (slacDBID,"SELECT * FROM FILE_INFO");genCodeID		= 0+(generalInfo[0])["genCodeID"];dataAdjective   = returnDataAdjective (genCodeID,0);dataType    = 0;if (genCodeID == (-1)){	dataType = 1;}else{	if (genCodeID == (-2))	{		dataType = 2;	}}if (siteIndex >= 0){	if (genCodeID >= 0)	{		if (contrastSites)		{			pv = _ExecuteSQL  (slacDBID,"SELECT * FROM SLAC_MUTATION WHERE ABSSITE = "+(siteIndex+1) + " OR ABSSITE = "+(siteIndex2+1) + " ORDER BY BRANCH ");			keyOrder = {{"Branch","AbsSite","StartCodon","StartAA","EndCodon","EndAA","S","NS"}};			doMap    = {{0,0,0,1,0,1,0,0}};		}		else		{			pv = _ExecuteSQL  (slacDBID,"SELECT * FROM SLAC_MUTATION WHERE ABSSITE = "+(siteIndex+1));			keyOrder = {{"Branch","StartCodon","StartAA","EndCodon","EndAA","S","NS"}};			doMap    = {{0,0,1,0,1,0,0}};		}		startRes = "StartCodon";		endRes	 = "EndCodon";	}	else	{		if (contrastSites)		{			pv = _ExecuteSQL  (slacDBID,"SELECT * FROM SUBSTITUTIONS WHERE ABSSITE = "+(siteIndex+1) + " OR ABSSITE = "+(siteIndex2+1) + " ORDER BY BRANCH ");			keyOrder = {{"Branch","AbsSite","StartResidue","EndResidue"}};		}		else		{			pv = _ExecuteSQL  (slacDBID,"SELECT * FROM SUBSTITUTIONS WHERE ABSSITE = "+(siteIndex+1));			keyOrder = {{"Branch","StartResidue","EndResidue"}};		}		startRes = "StartResidue";		endRes	 = "EndResidue";	}		subCount = Abs(pv);		if (contrastSites)	{		dualMap = {};		for (k = 0; k < subCount; k=k+1)		{			if (Abs(dualMap[(pv[k])["Branch"]&&1]) == 0)			{				dualMap[(pv[k])["Branch"]&&1] = {};			}			if (genCodeID < 0 || (0+(pv[k])["NS"]))			{				(dualMap[(pv[k])["Branch"]&&1])[(pv[k])["AbsSite"]] = 1;			}		}	}		if (Abs(pv) == 0)	{		ErrorOut ("No substitutions found at this site");		return 0;	}	if (outputMode == 2)	{			if (contrastSites)		{			fprintf (stdout, "<H1 CLASS = 'SuccessCap' style = 'text-transform: none;'>Comparing inferred substitutions for ",dataAdjective," sites ",siteIndex+1," and ", siteIndex2 + 1, "</H1>");				}		else		{			fprintf (stdout, "<H1 CLASS = 'SuccessCap' style = 'text-transform: none;'>Inferred substitution report for ",dataAdjective," site ",siteIndex+1,"</H1>");		}		fprintf (stdout, _makeJobIDHTML (filePrefix));		fprintf (stdout, "<DIV CLASS = 'RepClassSM'><b>Substitutions by branch.</b><span style = 'font-size:10px;'> &nbsp;");		if (genCodeID >= 0)		{			fprintf (stdout, "Codons with ambiguous nucleotides are reported as 'Mix'. The rows are color coded by type of substitutions as follows: <span style = 'background-color:orange;'>both synonymous and non-synonymous</span>,<span style = 'background-color:#88EB88;'>only synonymous</span>,<span style = 'background-color:#ED006A;color:white;'>only non-synonymous</span>.");		}				  						  		fprintf (stdout,  "Because the tree is unrooted, directionality of substitutions may be reversed. For counting substitutions, shortest evolutionary paths are assumed, and when multiple exist - the average over all is taken.</span>",						  "<p>Visualize on the phylogenetic tree as <a href='",BASE_CGI_URL_STRING,"siteMap.pl?file=",filePrefix,"&site=",rawSite,"&dataType=",dataType,"&mode=0'>[",dataAdjective,"s]</a>");						  		if (genCodeID >= 0)		{ 			fprintf (stdout, " or <a href='",BASE_CGI_URL_STRING,"siteMap.pl?file=",filePrefix,"&site=",rawSite,"&mode=1'>[AA]</a>"); 		}				sums     = {1,2};				columnCount    = Columns (keyOrder);		if (genCodeID >= 0)		{				if (contrastSites)			{				fprintf (stdout, "<TABLE BORDER = '0' CELLSPACING='0' style = 'margin:10px'><TR class = 'HeaderClass' style = 'font-size:13px;'><TD>Branch</TD><TD>Site</TD><TD COLSPAN = '2'>From</TD><TD COLSPAN = '2'>To</TD><TD COLSPAN = '2'>Substitutions</TD></TR>",						 "<TR class = 'HeaderClass' style = 'font-size:13px;'><TD></TD><TD></TD><TD>Codon</TD><TD>AA</TD><TD>Codon</TD><TD>AA</TD><TD>Synonymous</TD><TD>Non-synonymous</TD></TR>");			}			else			{				fprintf (stdout, "<TABLE BORDER = '0' CELLSPACING='0' style = 'margin:10px'><TR class = 'HeaderClass' style = 'font-size:13px;'><TD>Branch</TD><TD COLSPAN = '2'>From</TD><TD COLSPAN = '2'>To</TD><TD COLSPAN = '2'>Substitutions</TD></TR>",						 "<TR class = 'HeaderClass' style = 'font-size:13px;'><TD></TD><TD>Codon</TD><TD>AA</TD><TD>Codon</TD><TD>AA</TD><TD>Synonymous</TD><TD>Non-synonymous</TD></TR>");			}						lastBranchName = "";						for (r=0; r<subCount; r=r+1)			{				sc = 0+(pv[r])["S"];				nc = 0+(pv[r])["NS"];				if (sc > 0 && nc > 0)				{					fprintf (stdout, "<TR class = 'TRReportNS' style = 'font-size: 13px;background-color: orange;'>");				}				else				{					if (sc)					{						fprintf (stdout, "<TR class = 'TRReportNS' style = 'font-size: 13px;'>");								}					else					{						fprintf (stdout, "<TR class = 'TRReportPS' style = 'font-size: 13px;'>");												}				}								c = ((pv[r])[keyOrder[0]] == lastBranchName);								if (c == 1)				{					fprintf (stdout, "<TD></TD>");				}								for (; c<columnCount; c=c+1)				{					if (doMap[c])					{						fprintf (stdout, "<TD style='text-align: left;'>", MapCodeToAA(0+(pv[r])[keyOrder[c]]), "</TD>");							}					else					{						fprintf (stdout, "<TD style='text-align: left;'>", (pv[r])[keyOrder[c]], "</TD>");							}									}				lastBranchName = (pv[r])[keyOrder[0]];				fprintf (stdout, "</TR>\n");			}				}		else		{			if (contrastSites)			{				fprintf (stdout, "<TABLE BORDER = '0' CELLSPACING='0' style = 'margin:10px'><TR class = 'HeaderClass' style = 'font-size:13px;'><TD>Branch</TD><TD>Site</TD><TD>From</TD><TD>To</TD></TR>");			}			else			{				fprintf (stdout, "<TABLE BORDER = '0' CELLSPACING='0' style = 'margin:10px'><TR class = 'HeaderClass' style = 'font-size:13px;'><TD>Branch</TD><TD>From</TD><TD>To</TD></TR>");			}			lastBranchName = "";			styleToggle    = 1;			for (r=0; r<subCount; r=r+1)			{				c = ((pv[r])[keyOrder[0]] == lastBranchName);				if (c == 1)				{					fprintf (stdout, "<TR class = 'TRReport",1+styleToggle,"' style = 'font-size: 13px;'>");								fprintf (stdout, "<TD></TD>");				}				else				{					styleToggle = !styleToggle;					fprintf (stdout, "<TR class = 'TRReport",1+styleToggle,"' style = 'font-size: 13px;'>");							}				for (; c<columnCount; c=c+1)				{					fprintf (stdout, "<TD style='text-align: left;'>", (pv[r])[keyOrder[c]], "</TD>");						}				fprintf (stdout, "</TR>\n");				lastBranchName = (pv[r])[keyOrder[0]];			}						}		fprintf (stdout, "</TABLE></DIV>");	}	else	{		grabATree (0+(pv[0])["Partition"]);		parentMap = {};		for (r=1; r<Abs(T); r=r+1)		{			bn = (T[r])["Name"];			TREE_OUTPUT_OPTIONS[bn] = {};			(TREE_OUTPUT_OPTIONS[bn]) ["TREE_OUTPUT_BRANCH_LABEL"] = "";			(TREE_OUTPUT_OPTIONS[bn]) ["TREE_OUTPUT_BRANCH_COLOR"] = {{0.7,0.7,0.7}};			parentMap [bn] = (T[(T[r])["Parent"]])["Name"];		}						for (r=0; r<subCount; r=r+1)		{			bn = (pv[r])["Branch"];			if (genCodeID>=0)			{				sc = 0+(pv[r])["S"];				nc = 0+(pv[r])["NS"];			}			else			{				nc = 1;			}						if (contrastSites == 0)			{				if (outputMode == 1 && genCodeID >= 0)				{					(TREE_OUTPUT_OPTIONS[bn]) ["TREE_OUTPUT_BRANCH_TLABEL"] = MapCodeToAA(0+(pv[r])["EndAA"])+"("+bn+")";					(TREE_OUTPUT_OPTIONS[parentMap[bn]]) ["TREE_OUTPUT_BRANCH_TLABEL"] = MapCodeToAA(0+(pv[r])["StartAA"])+"("+parentMap[bn]+")";				}				else				{					(TREE_OUTPUT_OPTIONS[bn]) ["TREE_OUTPUT_BRANCH_TLABEL"] = (pv[r])[endRes]+"("+bn+")";					(TREE_OUTPUT_OPTIONS[parentMap[bn]]) ["TREE_OUTPUT_BRANCH_TLABEL"] =  (pv[r])[startRes]+"("+parentMap[bn]+")";				}			}			else			{				(TREE_OUTPUT_OPTIONS[bn]) ["TREE_OUTPUT_BRANCH_TLABEL"] 			  = bn;				(TREE_OUTPUT_OPTIONS[parentMap[bn]]) ["TREE_OUTPUT_BRANCH_TLABEL"]    = parentMap[bn];				brhits = Abs(dualMap[bn&&1]);				sc = 0;				nc = 0;				if (brhits == 2)				{					sc = 1; nc = 1;				}				else				{					if ((0+(Rows(dualMap[bn&&1]))[0])-1 == siteIndex)					{						sc = 1;					}					else					{						nc = 1;					}				}			}			if (sc > 0 && nc > 0)			{				(TREE_OUTPUT_OPTIONS[bn])["TREE_OUTPUT_BRANCH_COLOR"] = {{1.0,0.5,0}};			}			else			{				if (sc)				{					(TREE_OUTPUT_OPTIONS[bn])["TREE_OUTPUT_BRANCH_COLOR"] = {{0,0,1}};				}				else				{					(TREE_OUTPUT_OPTIONS[bn])["TREE_OUTPUT_BRANCH_COLOR"] = {{1,0,0}};				}			}			}		TREE_OUTPUT_OPTIONS["TREE_OUTPUT_XTRA_MARGIN"] = 6;		ht = Min(1600,Max(200,30 * height));		wd	 = Min(680, Max (200, depth*50+200));		/*		ht = Max(400,height*20);		wd = Max(400,depth*20);		*/				psString = PSTreeString (t,"EXPECTED_NUMBER_OF_SUBSTITUTIONS",{{ht,wd}});		fprintf (stdout, "/drawletter {5 5 rmoveto 1 copy false charpath pathbbox 2 index 3 sub sub exch 3 index 3 sub sub exch  0.85 setgray 4 copy rectfill 0 setgray  3 index 3 index currentlinewidth 0.5 setlinewidth 7 3 roll rectstroke setlinewidth exch 1.5 add exch 1.5 add moveto show} def\n", psString);	}}else/* return mutation maps by branch */{	pCount    = Abs(_ExecuteSQL (slacDBID,"SELECT * FROM SLAC_TREES"));		subsCount = {}; 		for (p=1; p<=pCount; p=p+1)	{		if (genCodeID >= 0)		{			pv = _ExecuteSQL  (slacDBID,"SELECT Branch,S,NS FROM SLAC_MUTATION WHERE PARTITION = "+p);		}		else		{			pv = _ExecuteSQL  (slacDBID,"SELECT * FROM SUBSTITUTIONS WHERE PARTITION = "+p);		}		subsCount [p] = {};		sc			  = Abs(pv);		if (sc > 0)		{			for (r = 0; r < sc; r=r+1)			{				bid = (pv[r])["Branch"];								if (Rows ((subsCount[p])[bid]) == 0)				{				 	(subsCount[p])[bid] = {2,1};				}				if (genCodeID >= 0)				{					((subsCount[p])[bid])[0] = ((subsCount[p])[bid])[0] + (pv[r])["S"];					((subsCount[p])[bid])[1] = ((subsCount[p])[bid])[1] + (pv[r])["NS"];				}				else				{					((subsCount[p])[bid])[0] = ((subsCount[p])[bid])[0] + 1;								}			}		}		}		if (outputMode == 2)	{		fprintf (stdout, "<H1 CLASS = 'SuccessCap' style = 'text-transform: none;'>Inferred substitution report</H1>");		fprintf (stdout, _makeJobIDHTML (filePrefix));		fprintf (stdout, "<DIV CLASS = 'RepClassSM'><b>Cumulative substitutions by partition/branch.</b><span style = 'font-size:10px;'> &nbsp;");		if (genCodeID >= 0)		{			fprintf (stdout, "The rows are color coded by type of substitutions as follows: <span style = 'background-color:orange;'>both synonymous and non-synonymous</span>,<span style = 'background-color:#88EB88;'>only synonymous</span>,<span style = 'background-color:#ED006A;color:white;'>only non-synonymous</span>.");		}				  						  		fprintf (stdout,  "For counting substitutions, shortest evolutionary paths are assumed, and when multiple exist - the average over all is taken.</span>",						  "<p>Visualize on the phylogenetic tree as <a href='",BASE_CGI_URL_STRING,"siteMap.pl?file=",filePrefix,"&site=-1&mode=0&dataType=",dataType,"'>[",dataAdjective,"s]</a></DIV>");									for (p=1; p<=pCount; p=p+1)		{			fprintf (stdout, "<DIV CLASS = 'RepClassSM'><b>Report for partition ",p,".</b>");			if (Abs(subsCount[p]) > 0)			{				if (genCodeID >= 0)				{					fprintf (stdout, "<TABLE BORDER = '0' CELLSPACING='0' style = 'margin:10px'><TR class = 'HeaderClass' style = 'font-size:13px;'><TD>Branch</TD><TD COLSPAN = '3'># Substitutions</TD></TR>",									  "<TR class = 'HeaderClass' style = 'font-size:13px;'><TD></TD><TD>Synonymous</TD><TD>Non-synonymous</TD><TD>Total</TD></TR>");				}				else				{					fprintf (stdout, "<TABLE BORDER = '0' CELLSPACING='0' style = 'margin:10px'><TR class = 'HeaderClass' style = 'font-size:13px;'><TD>Branch</TD><TD># Substitutions</TD></TR>");								}								branches = Rows(subsCount[p]);								for (bid = 0; bid < Columns (branches); bid = bid+1)				{					sc = (subsCount[p])[branches[bid]];					nc = sc[1];					sc = sc[0];					if (genCodeID >= 0)					{						if (sc && nc)						{							fprintf (stdout, "<TR class = 'TRReportNS' style = 'font-size: 13px;background-color: orange; text-align: left;'>");						}						else						{							if (sc)							{								fprintf (stdout, "<TR class = 'TRReportNS' style = 'font-size: 13px; text-align: left;'>");										}							else							{								fprintf (stdout, "<TR class = 'TRReportPS' style = 'font-size: 13px; text-align: left;'>");														}						}														fprintf (stdout, "<TD>", branches[bid], "</TD><TD>", sc, "</TD><TD>", nc, "</TD><TD>", sc+nc, "</TD></TR>\n"); 					}					else					{						fprintf (stdout, "<TR class = 'TRReport", bid%2+1,"' style = 'font-size: 13px; text-align: left;'><TD>", branches[bid], "</TD><TD>", sc, "</TD></TR>");										}							}				fprintf (stdout, "</TABLE></DIV>\n");			}			else			{				fprintf (stdout, "No substitutions for this partition</DIV>");			}				}	}	else	{		for (p=1; p<=pCount; p=p+1)		{			grabATree (p);						branches = Rows(subsCount[p]);			for (bid = 0; bid < Columns (branches); bid = bid+1)			{				bn = branches[bid];				sc = (subsCount[p])[bn];				nc = sc[1];				sc = sc[0];								TREE_OUTPUT_OPTIONS[bn] = {};				(TREE_OUTPUT_OPTIONS[bn]) ["TREE_OUTPUT_BRANCH_TLABEL"] = bn;				if (genCodeID >= 0)				{					(TREE_OUTPUT_OPTIONS[bn]) ["TREE_OUTPUT_OVER_BRANCH"] = "gsave 0.7 0.7 scale ("+sc+":"+nc+") drawletter grestore\n";					if (sc > 0 && nc > 0)					{						(TREE_OUTPUT_OPTIONS[bn])["TREE_OUTPUT_BRANCH_COLOR"] = {{1.0,0.5,0}};					}					else					{						if (sc)						{							(TREE_OUTPUT_OPTIONS[bn])["TREE_OUTPUT_BRANCH_COLOR"] = {{0,0,1}};						}						else						{							(TREE_OUTPUT_OPTIONS[bn])["TREE_OUTPUT_BRANCH_COLOR"] = {{1,0,0}};						}					}					}				else				{					(TREE_OUTPUT_OPTIONS[bn]) ["TREE_OUTPUT_OVER_BRANCH"] = "gsave 0.7 0.7 scale ("+sc+") drawletter grestore\n";									(TREE_OUTPUT_OPTIONS[bn])["TREE_OUTPUT_BRANCH_COLOR"] = {{1,0,0}};				}							}						psString = PSTreeString (t,"STRING_SUPPLIED_LENGTHS",{{-1,-1}});						fprintf (stdout, "/drawletter {5 5 rmoveto 1 copy false charpath pathbbox 2 index 3 sub sub exch 3 index 3 sub sub exch  0.85 setgray 4 copy rectfill 0 setgray  3 index 3 index currentlinewidth 0.5 setlinewidth 7 3 roll rectstroke setlinewidth exch 1.5 add exch 1.5 add moveto show} def\n", psString);		}		}}							_closeCacheDB (slacDBID);function grabATree (p){	treeS = (_ExecuteSQL  (slacDBID,"SELECT TREE FROM SLAC_TREES WHERE PARTITION = "+p))[0];	Tree t = treeS;		TREE_OUTPUT_OPTIONS = {};	TREE_OUTPUT_OPTIONS ["TREE_OUTPUT_LAYOUT"] = 0;	TREE_OUTPUT_OPTIONS ["TREE_OUTPUT_XTRA_MARGIN"] = 0;		T = t^0;		depth  = 0;	height = 0;		for (bid = 1; bid < Abs(T); bid=bid+1)	{		depth = Max(depth, (T[bid])["Depth"]);		if (Abs((T[bid])["Children"]) == 0)		{			height = height + 1;			}			}	return 0;}