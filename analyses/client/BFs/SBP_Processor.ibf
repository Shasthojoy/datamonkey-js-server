ExecuteAFile ("../Shared/TreeTools.ibf");/*---------------------------------------------------------------*/SBPTreesTable							  			 = {};SBPTreesTable 			["Site"]     				 = "INTEGER";SBPTreesTable 			["Tree1"] 		 			 = "STRING";SBPTreesTable 			["Tree2"]    	 			 = "STRING";SBPTreesTable 			["Tree1Length"] 		     = "REAL";SBPTreesTable 			["Tree2Length"]    	 		 = "REAL";SBPTreesTable 			["AIC"]  		 			 = "REAL";SBPTreesTable 			["cAIC"]  		 			 = "REAL";SBPTreesTable 			["BIC"]  		 			 = "REAL";SBPTreesTable 			["wAIC"]  		 			 = "REAL";SBPTreesTable 			["wcAIC"]  		 			 = "REAL";SBPTreesTable 			["wBIC"]  		 			 = "REAL";SBPTreesTable 			["SplitsMatch"]  		 	 = "INTEGER";SBPTreesTable 			["RF"]  		 			 = "INTEGER";sscanf (rawIn,"String,Number,Number,Number,Number,Number,Number,String",			   modelDesc,			   baseLogL,			   baseDF,			   canUseAICc,			   baseAIC,			   baseAICc,			   baseBIC,			   baseTree			   );		treeRecordsAVL = {};sscanf 		 	(rawIn, "Lines", aLine);bestScores 		= {3,4}["-1"];sums	   		= {3,1};splitString = "";siteCount = 0+(_ExecuteSQL  (slacDBID,"SELECT SITES FROM FILE_INFO"))[0];dataType			= 0+(_ExecuteSQL  (slacDBID,"SELECT GENCODEID FROM FILE_INFO"))[0];if (dataType >= 0){	siteCount = siteCount * 3;}spanMatrix = {2,1};treeMatrix = {2,1};spanMatrix [1] = siteCount;for (l=0; l<Columns(aLine);l=l+1){	splitLine = splitStringByTab (aLine[l]);	if (Abs (splitLine) == 6)	/* tree entry */	{		aRecord = {};		aRecord["Site"]  		= 1+splitLine[0];		aRecord["AIC"]   		= 0+splitLine[1];		aRecord["cAIC"]  		= 0+splitLine[2];		aRecord["BIC"]   		= 0+splitLine[3];		aRecord["Tree1"] 		= splitLine[4];		aRecord["Tree2"] 		= splitLine[5];		aRecord["Tree1Length"] 	= makeTreeStatString(splitLine[4]);		aRecord["Tree2Length"]  = makeTreeStatString(splitLine[5]);												ExecuteCommands ("Tree TP1 = " + aRecord["Tree1"]);		rootOn = TipName (TP1, 0);		rooted1 = RerootTree (TP1,rootOn);		reduced1 = (rooted 1 ^{{"\,[^\,]+$"}{""}});		reduced1 = (reduced1)[1][Abs(reduced1)-1];		ExecuteCommands ("Tree TP2 = " + aRecord["Tree2"]);		rooted1 = RerootTree (TP2,rootOn);		reduced2 = (rooted 1 ^{{"\,[^\,]+$"}{""}});		reduced2 = (reduced2)[1][Abs(reduced2)-1];				ExecuteCommands ("Tree TP1 = " + reduced1);		ExecuteCommands ("Tree TP2 = " + reduced2);		d = TP1*TP2;						aRecord["SplitsMatch"] 	= (d["CLUSTERS"])[1];		aRecord["RF"]           = (d["CLUSTERS"])[0]-(d["CLUSTERS"])[1];						treeRecordsAVL[Abs(treeRecordsAVL)] = aRecord;		icDiff = baseAIC-aRecord["AIC"];		if (icDiff > bestScores[0][0])		{			bestScores[0][0] = icDiff;			bestScores[0][1] = aRecord["AIC"];			bestScores[0][2] = aRecord["Site"];			if (!canUseAICc)			{				treeMatrix [0] = (splitLine[4]);				treeMatrix [1] = (splitLine[5]);				spanMatrix [0] = aRecord["Site"];						}		}		if (canUseAICc)		{			icDiff = baseAICc-aRecord["cAIC"];			if (icDiff > bestScores[1][0])			{				bestScores[1][0] = icDiff;				bestScores[1][1] = aRecord["cAIC"];				bestScores[1][2] = aRecord["Site"];				if (icDiff > 0)				{					treeMatrix [0] = (splitLine[4]);					treeMatrix [1] = (splitLine[5]);					spanMatrix [0] = aRecord["Site"];				}			}				}		icDiff = baseBIC-aRecord["BIC"];		if (icDiff > bestScores[2][0])		{			bestScores[2][0] = icDiff;			bestScores[2][1] = aRecord["BIC"];			bestScores[2][2] = aRecord["Site"];		}			}	else	{		if (Abs(splitLine) == 3)		{			processedBP = 0 + splitLine[0];			totalBP 	= 0 + splitLine[1];			timeSoFar   = 0 + splitLine[2];			break;		}	}}SBP_SummaryTable                = {};SBP_SummaryTable ["COL_KEY"]    = "STRING";SBP_SummaryTable ["COL_VALUE"]  = "STRING";_CheckDBID 		  (slacDBID,"SBP_SUMMARY",SBP_SummaryTable);record = {};record ["COL_KEY"] = "ModelDescription";record ["COL_VALUE"] = modelDesc;_InsertRecord (slacDBID,"SBP_SUMMARY", record);record ["COL_KEY"] = "canUseAICc";record ["COL_VALUE"] = canUseAICc;_InsertRecord (slacDBID,"SBP_SUMMARY", record);record ["COL_KEY"] = "baseAIC";record ["COL_VALUE"] = baseAIC;_InsertRecord (slacDBID,"SBP_SUMMARY", record);record ["COL_KEY"] = "baseAICc";record ["COL_VALUE"] = baseAICc;_InsertRecord (slacDBID,"SBP_SUMMARY", record);record ["COL_KEY"] = "baseBIC";record ["COL_VALUE"] = baseBIC;_InsertRecord (slacDBID,"SBP_SUMMARY", record);if (spanMatrix[0]>0){	UseModel (USE_NO_MODEL);	ts	   = treeMatrix[0];	Tree t = ts;	tavl = t^0;	treeMatrix[0] = KillInternalZeroBranchLengths (tavl);	record ["COL_KEY"]   = "TREE1";	record ["COL_VALUE"] = treeMatrix[0];	_InsertRecord (slacDBID,"SBP_SUMMARY", record);		ts	   = treeMatrix[1];	Tree t = ts;	tavl = t^0;	treeMatrix[1] = KillInternalZeroBranchLengths (tavl);	splitString   = _makeSplitsString (treeMatrix, spanMatrix);		record ["COL_KEY"]   = "TREE2";	record ["COL_VALUE"] = treeMatrix[1];	_InsertRecord (slacDBID,"SBP_SUMMARY", record);	record ["COL_KEY"]   = "BP";	record ["COL_VALUE"] = spanMatrix[0];	_InsertRecord (slacDBID,"SBP_SUMMARY", record);}if (bestScores[0][0] > 0){	baseAIC  = Exp ((bestScores[0][1]-baseAIC)*0.5);}else{	baseAIC = 1;}if (canUseAICc){	if (bestScores[1][0] > 0)	{		baseAICc = Exp ((bestScores[1][1]-baseAICc)*0.5);	}	else	{		baseAICc = 1;	}}if (bestScores[2][0] > 0){	baseBIC  = Exp ((bestScores[2][1]-baseBIC)*0.5);}else{	baseBIC = 1;}for (l = 0; l<Abs(treeRecordsAVL); l=l+1){	(treeRecordsAVL[l])["wAIC"] = Exp ((bestScores[0][1]-(treeRecordsAVL[l])["AIC"])*0.5);	sums[0] = sums[0] + (treeRecordsAVL[l])["wAIC"];	if (canUseAICc)	{		(treeRecordsAVL[l])["wcAIC"] = Exp ((bestScores[1][1]-(treeRecordsAVL[l])["cAIC"])*0.5);		sums[1] = sums[1] + (treeRecordsAVL[l])["wcAIC"];	}	(treeRecordsAVL[l])["wBIC"] = Exp ((bestScores[2][1]-(treeRecordsAVL[l])["BIC"])*0.5);	sums[2] = sums[2] + (treeRecordsAVL[l])["wBIC"];}bestScores[0][3] = sums[0]/(baseAIC+sums[0]);if (canUseAICc){	bestScores[1][3] = sums[1]/(baseAICc+sums[1]);}bestScores[2][3] = sums[2]/(baseBIC+sums[2]);for (l = 0; l<Abs(treeRecordsAVL); l=l+1){	(treeRecordsAVL[l])["wAIC"] = (treeRecordsAVL[l])["wAIC"]/(baseAIC+sums[0]);	if (canUseAICc)	{		(treeRecordsAVL[l])["wcAIC"] = (treeRecordsAVL[l])["wcAIC"]/(baseAICc+sums[1]);	}	(treeRecordsAVL[l])["wBIC"] = (treeRecordsAVL[l])["wBIC"]/(baseBIC+sums[2]);}record ["COL_KEY"] = "bestScores";record ["COL_VALUE"] = bestScores;_InsertRecord (slacDBID,"SBP_SUMMARY", record);_CheckDBID (slacDBID,"SBP_TREES",SBPTreesTable);_InsertMultipleRecords (slacDBID,"SBP_TREES",treeRecordsAVL);		fprintf (stdout, "<script type='text/javascript' src='http://www.datamonkey.org/wz_tooltip.js'></script><H1 CLASS='SuccessCap'>SBP analysis results</H1>");		jobFileName = BASE_CGI_URL_STRING + "slacreport.pl?file=" + filePrefix + "&task=20&format=";fprintf (stdout, "<DIV CLASS='RepClassCT'><b>Reports</b> <a href='",jobFileName,"0'>[HTML]</a> <a href='",			        jobFileName,"1' target = '_blank'>[CSV]</a> <a href='",jobFileName,"2",			        "'>[Plots]</a></DIV>");					        fprintf (stdout, _makeJobIDHTML(filePrefix));				 fprintf (stdout, "<DIV class = 'RepClassSM'><b>Single breakpoint (SBP) analysis summary</b><p>",				 "<TABLE>",				 "<TR CLASS = 'TRReport1'><TD>Model</TD><TD>", modelDesc, "</TD></TR>",				 "<TR CLASS = 'TRReport2'><TD>Potential Breakpoints</TD><TD>", totalBP, "</TD></TR>",				 "<TR CLASS = 'TRReport1'><TD>Processed Breakpoints</TD><TD>", processedBP+1, "</TD></TR>",				 "<TR CLASS = 'TRReport2'><TD>Run time</TD><TD>", _formatTimeString(timeSoFar), "</TD></TR>",				 "</TABLE>"		);if (processedBP+1 < totalBP){	fprintf (stdout, "<DIV class = 'WarnClassSM'>Due to computational time restrictions not all possible breakpoints were considered. Consider using a simpler model (e.g. no rate variation), reducing the size of the dataset, or running SBP locally</DIV>");}fprintf (stdout, "</DIV>");fprintf (stdout, "<DIV class = 'RepClassSM'><b>Recombination report</b><br>",				 "<i>Small sample AIC (cAIC) is the recommended default criterion</i>\n<p><table>",				 		"<tr class = 'HeaderClassSM'><td>IC <span class = 'INFO' onmouseover = \"Tip('Which information criterion is used for inference')\">?</span></td>",				 		"<td>Recombination <span class = 'INFO' onmouseover = \"Tip('Was recombination inferred using this IC?')\">?</span></td>",				 		"<td>IC improvement <span class = 'INFO' onmouseover = \"Tip('How many points did the recombinant model improve the IC over the base (single tree) model?')\">?</span></td>",				 		"<td>Breakpoint location<span class = 'INFO' onmouseover = \"Tip('Where is the most likely breakpoint located?')\">?</span></td>",				 		"<td>Model averaged support<span class = 'INFO' onmouseover = \"Tip('Model averaged confidence for having recombination in the alignment')\">?</span></td></tr>",						 reportImprovementHTML (0,"AIC",1,0), "\n");if (canUseAICc){	fprintf (stdout,reportImprovementHTML (1,"cAIC",2,1), "\n");}else{	fprintf (stdout,"<tr><td>cAIC</td><td colspan='4'>Could not be applied to this alignment; it has too few sites for the number of sequences</td></tr>");}fprintf (stdout,reportImprovementHTML (2,"BIC",1,0), "</table></DIV>");				 /* ________________________________________________________________________________________________*/function makeTreeStatString (treeString){	UseModel (USE_NO_MODEL);	Tree _it = treeString;	bl = BranchLength (_it,-1);	return (Transpose(bl)*(bl["1"]))[0];}/*---------------------------------------------------------------------------------------------------------------------------------------------*/function	reportImprovementHTML (_index, _IC, rowCode, boldMe){	if (bestScores[_index][0] >= 0)	{		if (boldMe)		{			extraClass = "style = 'font-size: 14px;'";		}		else		{			extraClass = "";		}		return "<tr class = 'TRReport"+rowCode+"'" + extraClass + "><td>" + _IC + "</td><td>Yes</td><td>"+									 bestScores[_index][0] + "</td><td>"+									 bestScores[_index][2] + "</td><td>"+									 Format(bestScores[_index][3]*100,5,2) +  "%</td></tr>";									}	return "<tr class = 'TRReport"+rowCode+"'><td>" + _IC + "</td><td>No</td><td>N/A</td><td>N/A</td><td>"+Format(bestScores[_index][3]*100,5,2) +  "%</td></tr>";}