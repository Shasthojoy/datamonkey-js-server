ExecuteAFile ("../../Shared/HyPhyGlobals.ibf");ExecuteAFile ("../../Shared/GrabBag.bf");ExecuteAFile ("../../Shared/ReadDelimitedFiles.bf");ExecuteAFile ("../../Shared/DBTools.ibf");skipCodeSelectionStep = 1;ExecuteAFile ("../../Shared/chooseGeneticCode.def");fscanf		 (stdin, "String", arg);arg = splitOnRegExp (arg,"-");if (Abs (arg) != 5){	defaultErrorOut ("Argument Error");	return 0;}slacDBID 		 = _openCacheDB      (arg[0]);haveASR 	     = _TableExists (slacDBID, "ASR_SUMMARY");if (haveASR){	siteInfo = _ExecuteSQL  (slacDBID,"SELECT * FROM ASR_RESIDUES_TABLE WHERE PARTITION = " + arg[1] + " AND SEQUENCE = " + arg[2] + " AND SITE = " + arg[3]);	mInfo = _ExecuteSQL     (slacDBID,"SELECT * FROM ASR_MARGINAL_DUMP WHERE PARTITION = " + arg[1]  + " AND SEQUENCE = " + arg[2] + " AND SITE = " + arg[3]);	sInfo = _ExecuteSQL     (slacDBID,"SELECT * FROM ASR_SAMPLED_DUMP WHERE PARTITION = " + arg[1]   + " AND SEQUENCE = " + arg[2] + " AND SITE = " + arg[3]);	if (Abs(siteInfo)*Abs(mInfo)*Abs(sInfo) == 0)	{		defaultErrorOut ("Invalid partition/site/sequence combination");		_closeCacheDB (slacDBID);		return 0;	}	asrInfo = _ExecuteSQL  (slacDBID,"SELECT COL_VALUE FROM ASR_SUMMARY WHERE COL_KEY = 'Nodemap'");	alphabet = _ExecuteSQL  (slacDBID,"SELECT COL_VALUE FROM ASR_SUMMARY WHERE COL_KEY = 'Alphabet'");	ExecuteCommands ("asrInfo = " + asrInfo[0]);	ExecuteCommands ("alphabet = " + alphabet[0]);	partInfo = _ExecuteSQL  (slacDBID,"SELECT * FROM ASR_PARTITION_TABLES WHERE PARTITION = " + arg[1]);	ExecuteCommands ("Tree T = " + (partInfo[0])["TREE"]);				partNumber = 0 + arg[1];	seqNumber  = 0 + arg[2];	siteNumber = 0 + arg[3];	absSiteNumber = 0 + arg[4];		myNodeName = ((partInfo[0])["NODE_MAP"]);	ExecuteCommands ("myNodeName = "+ myNodeName);	myNodeName = myNodeName[seqNumber];		for (internalSeq = BranchCount (T)-1; internalSeq>=0; internalSeq=internalSeq-1)	{		if (BranchName(T,internalSeq) == myNodeName)		{			break;		}	}	if (internalSeq < 0) /* root */	{		myNodeName = "Node0";	}		fprintf (stdout, "<H1 class = 'SuccessCap'>ASR for ", myNodeName, " site ", siteNumber+1, "(", absSiteNumber+1,") in partition ", partNumber+1, "</H1>");	fprintf (stdout, _makeJobIDHTML(arg[0]));		ml = (siteInfo[0])["JOINT"];	ma = (siteInfo[0])["MARGINAL"];	sa = (siteInfo[0])["SAMPLED"];	fprintf (stdout, "<DIV CLASS = 'RepClassSM'><span style='font-variant:small-caps;font-size:18px;'><b>Inferred residue report.</b></span>",					 "<DL>",					 "<DT class = 'DMDT'>Joint maximum likelihood:<DD>", ml,					 "<DT class = 'DMDT'>Marginal maximum likelihood:<DD>", ma , " (support: ", Format(100*(0+(siteInfo[0])["MARGINALP"]),5,2), "%)",					 "<DT class = 'DMDT'>Mode of the sampled distribution (100 samples):<DD>", sa, " (support: ", Format(100*(0+(siteInfo[0])["SAMPLEDP"]),5,2), "%)",					 );		fprintf (stdout, "</DL></DIV>"); 	thresh = 0.001;	fprintf (stdout, "<DIV CLASS = 'RepClassSM'><table border = '0' style='spacing:30px;'><tr><td><b>Residues with at least 0.1% support.</b><td><b>Observed site composition.</b></td></tr><tr><td>");	characterCount = Columns(alphabet);		retained		   = {};	orderedM		   = {characterCount,2} ["_MATRIX_ELEMENT_ROW_"];	for (k = 0; k < characterCount; k=k+1)	{		orderedM [k][0] = 0 + (mInfo[0])[alphabet[k]];		if (orderedM [k][0] >= thresh)		{			retained[alphabet[k]] = 1;		}	}	orderedM = orderedM % 0;	for (k = 0; k < characterCount; k=k+1)	{		if (0 + (sInfo[0])[alphabet[k]] >= thresh)		{			retained[alphabet[k]] = 1;		}	}		fprintf (stdout, "<TABLE BORDER = 0 SPACING = '10px'><TR class = 'HeaderClassSM'><TD>Residue</TD><TD>Marginal Support</TD><TD>Sampled Support</TD></TR>");	z = 0;	for (k = characterCount - 1; k >= 0; k = k-1)	{		char = alphabet[orderedM[k][1]];		if (retained[char])		{			fprintf (stdout, "<TR CLASS = 'TRReport", 1+(z%2), "'><TD>",char,"</TD><TD>",Format((0+(mInfo[0])[char])*100,5,2),"%</TD><TD>",Format((0+(sInfo[0])[char])*100,5,2),"%</TD></TR>");			z = z + 1;		}	}	fprintf (stdout, "</TABLE>");	generateFilteredData (arg[0], slacDBID, absSiteNumber);	GetString	   (seqLabels, filteredData, -1);	GetInformation (siteInfo2, filteredData);	siteInfo3 = vectorToAVLFreqs (siteInfo2);		fprintf (stdout, "</td><td>");	_printAnAVL (siteInfo3,"Residue");		treeFileOut = BASE_OUTPUT_PATH + arg[0] + "_asr_" + seqNumber + "_" + absSiteNumber + ".ps";	nodeLabels = {};	for (k = 0; k < Columns (siteInfo2); k = k+1)	{		nodeLabels[seqLabels[k]] = siteInfo2[k];	}	nodeLabels[myNodeName] = ml;	if (ma != ml)	{		nodeLabels[myNodeName] = nodeLabels[myNodeName] + "/" + ma;	}	if (sa != ma && sa != ml)	{		nodeLabels[myNodeName] = nodeLabels[myNodeName] + "/" + sa;		}	fprintf (treeFileOut,CLEAR_FILE, _returnTreePS ((partInfo[0])["TREE"], "",nodeLabels));			fprintf (stdout, "</td></tr></table></DIV>"); 	fprintf (stdout, "<DIV CLASS = 'RepClassSM'><b>Site tree</b><p><img border = '1' src = '", 				 BASE_CGI_URL_STRING,"renderPSImage.pl?file=",arg[0],"_asr_",seqNumber,"_",absSiteNumber, 				 "'></DIV>");	}else{	defaultErrorOut ("ASR analysis has not been run for this file");}_closeCacheDB (slacDBID);