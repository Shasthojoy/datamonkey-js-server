ExecuteAFile ("../Shared/TreeTools.ibf");
ExecuteAFile ("ProcessorsShared.ibf");

fName			= BASE_OUTPUT_PATH + filePrefix +"_" + suffix[kind] + ".php";
fprintf			(fName, CLEAR_FILE,"<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'><html><head><meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1'><meta http-equiv='refresh' content='60'><title>Almost there...</title></head><body>Generating a report...this page will refresh in 1 minute (or you can try sooner)");

/*---------------------------------------------------------------*/

GARDBreakpointTable						  			 = {};
GARDBreakpointTable 			["Site"]     		 = "INTEGER";
GARDBreakpointTable				["BPSupport"]		 = "REAL";
GARDBreakpointTable				["TreeLength"]		 = "REAL";

siteCount 			= 0+(_ExecuteSQL  (slacDBID,"SELECT SITES FROM FILE_INFO"))[0];
dataType			= 0+(_ExecuteSQL  (slacDBID,"SELECT GENCODEID FROM FILE_INFO"))[0];

if (dataType >= 0)
{
	siteCount = siteCount * 3;
}

if ((rawIn $ "^ERROR")[0] == 0)
{
	defaultErrorOut (rawIn[6][-1]);
	return 0;
}

sscanf		   (rawIn, "Number,Number,Number,Number,Number,Number,Number,Number",
						timeElapsed,
						timeLeft,
						totalModelCount,
						lastImprovedBPC,
						numberOfFrags,
						rvChoice,
						rvRates,
						totalBP);
						
sscanf		   		(rawIn, "String", modelDescString);
						
sscanf			    (rawIn, "Number", baselineScore);						
aicSteps = {numberOfFrags,1};
bpLocs   = {};

aicSteps [0] = baselineScore;


for (k = 1; k <= lastImprovedBPC; k=k+1)
{
	sscanf		   (rawIn, "Number,NMatrix", score,pbps);
	aicSteps[k] = score;
	bpLocs  [k] = pbps;	
}


sscanf		   		(rawIn, "Matrix", characters);
sscanf		  		(rawIn, "NMatrix", rateMatrix);
rateMatrix 		   = (rateMatrix["_MATRIX_ELEMENT_VALUE_*(_MATRIX_ELEMENT_ROW_!=_MATRIX_ELEMENT_COLUMN_)"]);
if (rvChoice>0)
{
	sscanf		  		(rawIn, "NMatrix", cI);
}



if (lastImprovedBPC)
{
	sscanf	(rawIn, "Number", singleTreeAIC);
	sscanf  (rawIn, "NMatrix,NMatrix", pairwiseLikelihoodScores, pairwisePValues);
}

fprintf (stdout, "<script type='text/javascript' src='http://www.datamonkey.org/wz_tooltip.js'></script><H1 CLASS='SuccessCap'>GARD analysis results</H1>");

inFile = BASE_CLUSTER_ACCESS_PATH + filePrefix;
DataSet ds = ReadDataFile (inFile);
DataSetFilter filteredData = CreateFilter (ds,1);
DATA_FILE_PRINT_FORMAT = 6;

inFile = BASE_OUTPUT_PATH + filePrefix + "_gard.nex";

fprintf (inFile, CLEAR_FILE, filteredData);

jobFileName = BASE_CGI_URL_STRING + "slacreport.pl?file=" + filePrefix + "&task=21&format=";

fprintf (stdout, "<DIV CLASS='RepClassCT'><b>Reports</b> <a href='",jobFileName,"0'>[HTML]</a> <a href='",
			        jobFileName,"1' target = '_blank'>[CSV]</a> <a href='",jobFileName,"2",
			        "'>[Plots]</a> <a href='",jobFileName,"3",
			        "'>[Trees]</a> <a href='",filePrefix,"_gard.nex",
			        "'>[NEXUS]</a></DIV>");		
		
fprintf (stdout, _makeJobIDHTML(filePrefix));

mcc = countModels 	 (totalBP, lastImprovedBPC+1);
				 
fprintf (stdout, "<DIV class = 'RepClassSM'><b>Execution summary</b><p>",
				 "GARD examined ", totalModelCount, " models in ", _formatTimeString(timeElapsed), " wallclock time, at a rate of ", Format(totalModelCount/timeElapsed,6,2), " models/second. ",
				 "The alignment contained ", totalBP, " potential breakpoints, translating into the search space of ", mcc, " models with up to ", lastImprovedBPC+1, " breakpoints of which ",
				 Format (totalModelCount/mcc*100, 6,2), "% was explored by the genetic algorithm.</DIV>"
		);



if (timeLeft < 0)
{
	fprintf (stdout, "<DIV class = 'WarnClassSM'>This analysis was stopped before convergence, because the CPU time limit per job was reached. The reported results may, therefore be incomplete, as there may be more breakpoints, for example. ",
					  "Consider reducing the size of the alignment, either by removing sequences or selecting shorter sequence regions, or choosing a simpler model (for instance, without rate variation). </DIV>\n");
}

fprintf (stdout, "<DIV class = 'RepClassSM'><b>Recombination report</b><p>");

bestScore = baselineScore;

if (lastImprovedBPC)
{
	fprintf (stdout, "<i>GARD found evidence of ",lastImprovedBPC," breakpoints</i><p>", spoolAICTable(aicSteps,bpLocs, "bestScore"));
}
else
{
	fprintf (stdout, "<i>GARD found no evidence of recombination</i>");
}



fprintf (stdout, "</DIV>");


KHSupportedCount = 0;

if (lastImprovedBPC)
{
	fprintf (stdout, "<DIV class = 'RepClassSM'><b>Topological incongruence report</b><p>");
	fprintf (stdout, "<div style = 'width: 95%; border: 1px dashed black; spacing: 5px; padding: 5px;'>Comparing the AIC<sub>c</sub> score of the best fitting GARD model, that allows for different topologies between segments (", currentAIC,"), and that of the model that assumes the same tree for all the partitions ",
					 " inferred by GARD the same tree, but allows different branch lengths between partitions (", singleTreeAIC, ") suggests that because ");
	w = Exp(0.5*(currentAIC-singleTreeAIC));
	if (w > 0.01)
	{
		fprintf (stdout, "the multiple tree model <b>cannot</b> be preferred over the single tree model by an evidence ratio of 100 or greater, <i>some or all of the breakpoints may reflect rate variation instead of topological incongruence</i>.");
	}
	else
	{
		fprintf (stdout, "the multiple tree model <b>can</b> be preferred over the single tree model by an evidence ratio of 100 or greater, <i>at least of one of the breakpoints reflects</i> a true topological incorguence.");
	
	}
	
	fprintf (stdout, "<p><span style = 'font-size:10px;'> Please consult the following Kishino Hasegawa topological incongruence table for more details.</span></div>");
	fprintf (stdout, spoolKHTable (pairwisePValues,bpLocs));
	
	fprintf (stdout, "</div>");
}


displayModelMatrix (modelDescString,characters,rateMatrix,rvChoice,cI);

modelRecords = {};


splitString = "";

bpSupport  		= {siteCount,1};
treeLength  	= {siteCount,1};

normalizer		= 0;

GARD_SplitsTable                = {};
GARD_SplitsTable ["PART"]       = "NUMBER";
GARD_SplitsTable ["LEFT"]       = "NUMBER";
GARD_SplitsTable ["RIGHT"]      = "NUMBER";
GARD_SplitsTable ["TREE"]       = "STRING";
GARD_SplitsTable ["KHL"]         = "NUMBER";
GARD_SplitsTable ["KHR"]         = "NUMBER";

_CheckDBID 		  (slacDBID,"GARD_SPLITS",GARD_SplitsTable);

spans = "";
trees = "";
for (l=0; l<=lastImprovedBPC; l=l+1)
{
	aRecord 		= {};
	aRecord["PART"] = l;
	sscanf 		 	(rawIn, "String", aTree);
	aRecord["TREE"] = aTree;
	sscanf 		 	(rawIn, "String", aSplit);
	fromTo  = splitOnRegExp(aSplit,"\\-");
	aRecord["LEFT"] = (-1)+fromTo[0];
	aRecord["RIGHT"]   = (-1)+fromTo[1];
	if (l)
	{
		aRecord["KHL"]   = KHTestTables[l-1][0];	
		aRecord["KHR"]   = KHTestTables[l-1][1];	
	}
	
	spans = spans + "\tCHARSET SPAN_" + (l+1) + " = " + fromTo[0] + "-" + fromTo[1] + ";\n";
	trees = trees + "\tTREE TREE_" + (l+1) + " = " + aTree + ";\n";

	_InsertRecord (slacDBID,"GARD_SPLITS", aRecord);
}

fprintf (inFile, "\nBEGIN TREES;\n", trees, "END;\nBEGIN ASSUMPTIONS;\n", spans, "END\n");

sscanf 		 	(rawIn, "Lines", aLine);

fprintf			(fName,"<p>Read analysis results. Computing model averaged estimates of breakpoint locations based on ", Columns(aLine)$3, " models ");

for (l=1; l<Columns(aLine);l=l+3)
{
	spans 		= splitOnRegExp(aLine[l],"\\,");
	treeLengts	= splitOnRegExp(aLine[l+1],"\\,");
	
	modelScore	= Exp (0.5*(bestScore-(0+aLine[l+2])));
	
	if (modelScore > 0.00001)
	{
		for (s = 0; s < Abs(spans); s = s + 1)
		{
			fromTo  = splitOnRegExp(spans[s],"\\-");
			fromSite = 0 + fromTo[0];
			toSite   = 0 + fromTo[1];
			
			stencilMatrix = bpSupport["(_MATRIX_ELEMENT_ROW_>=fromSite)*(_MATRIX_ELEMENT_ROW_<=toSite)"];
			if (s>0)
			{
				bpSupport[fromSite] = bpSupport[fromSite]+modelScore;
			}
			treeLength = treeLength + stencilMatrix*(0+treeLengts[s])*modelScore;
			
		}
		normalizer = normalizer + modelScore;
	}
	
	if (l>1 && (l-1)%3000 == 0)
	{
		fprintf			(fName,"<br>", (l)$3, "/",  Columns(aLine)$3, " done " );
	}
}



bpSupport  = bpSupport * (1/normalizer);
treeLength = treeLength * (1/normalizer);


GARD_SummaryTable                = {};
GARD_SummaryTable ["COL_KEY"]    = "STRING";
GARD_SummaryTable ["COL_VALUE"]  = "STRING";

_CheckDBID 		  (slacDBID,"GARD_SUMMARY",GARD_SummaryTable);

record = {};
record ["COL_KEY"] = "ModelDescription";record ["COL_VALUE"] = modelDescString;_InsertRecord (slacDBID,"GARD_SUMMARY", record);
record ["COL_KEY"] = "Breakpoints";     record ["COL_VALUE"] = lastImprovedBPC;_InsertRecord (slacDBID,"GARD_SUMMARY", record);
record ["COL_KEY"] = "AICImprovement";  record ["COL_VALUE"] = baselineScore-bestScore;_InsertRecord (slacDBID,"GARD_SUMMARY", record);
record ["COL_KEY"] = "KHSupported";     record ["COL_VALUE"] = KHSupportedCount;_InsertRecord (slacDBID,"GARD_SUMMARY", record);


_CheckDBID 		  (slacDBID,"GARD_DETAILS",GARDBreakpointTable);


bpRecords = {};

for (l = 0; l<siteCount; l=l+1)
{
	bpRecords[l] = {};
	(bpRecords[l])["Site"] = 1+l;
	(bpRecords[l])["BPSupport"]  = bpSupport[l];
	(bpRecords[l])["TreeLength"] = treeLength[l];
}


_InsertMultipleRecords (slacDBID,"GARD_DETAILS",bpRecords);


				
/*---------------------------------------------------------------------------------------------------------------------------------------------*/

function 	countModels   (totalBP, bpc)
{
	total           = 0;
	currentNchooseK = totalBP;
	
	for (_k = 1; _k <= bpc; _k = _k + 1)
	{
		total = total + currentNchooseK;
		currentNchooseK = currentNchooseK * (totalBP - _k)/(_k+1);
		
	}
	return total;
}

/*---------------------------------------------------------------------------------------------------------------------------------------------*/

function 	spoolAICTable (byBPImprovement,byBPSplits, bestAIC&)
{
	colorList 	= {{"red","black","blue","green","purple","orange"}};
	fcolorList 	= {{"white","white","white","white","white","black"}};

	htmlAICTable = "";
	htmlAICTable * 128;


	htmlAICTable * "<div style = 'width: 580px; border: black dashed 1px; '>";
	htmlAICTable * ("<table style = 'width: 100%;font-size: 10px;text-align:left;'><tr>"+
					"<td>BPs <span class = 'INFO' onmouseover = \"Tip('Number of breakpoints in the model')\">?</span></td>"+
					"<td>AIC<sub>c</sub> <span class = 'INFO' onmouseover = \"Tip('AIC-c score for the best model with this many BPs')\">?</span></td>"+
					"<td>&Delta; AIC<sub>c</sub> <span class = 'INFO' onmouseover = \"Tip('AIC-c improvement relative to the model with one fewer breakpoint')\">?</span></td>"+
					"<td width = '70%'>Segments <span class = 'INFO' onmouseover = \"Tip('Non-recombinant segments returned by the model with the best score')\">?</span></td></tr>");
				   
	currentAIC = byBPImprovement [0];

	for (_partCount = 0; _partCount <=Abs (byBPSplits); _partCount = _partCount + 1)
	{
		if (_partCount)
		{
			currentAIC = currentAIC - byBPImprovement [_partCount];
			ci 		   = byBPImprovement [_partCount];
			bpLocs2     = byBPSplits		 [_partCount];
			pxPerSpan  = 406/siteCount;
			sp		   = "<table style = 'padding: 0px; spacing: 0px;'><tr>";
			
			prv 	   = Rows (bpLocs2);
			bpLocs	   = {1,prv+1};
			for (k = 0; k < prv; k=k+1)
			{
				bpLocs[k]	 = bpLocs2[k];
			}
			
			bpLocs[prv]  = siteCount-1;
			prv 	     = 1;
			
			bestAIC      = currentAIC;
			
			for (k=0; k<Columns (bpLocs); k=k+1)
			{
				sp = sp + "<td style = 'width:"+
					 pxPerSpan*(bpLocs[k]-prv+1)$1+
					 "px; background-color: "+
					 colorList[k%Columns(colorList)]+
					 "; color: "+
					 fcolorList[k%Columns(colorList)]+
					 "; text-align: right; font-size: 10px;'>";
					 
				if (k<Columns (bpLocs)-1)
				{
					sp = sp + (bpLocs[k] + 1);	
				}
				else
				{
					sp = sp + "&nbsp";	
				}
				sp = sp + "</td>";
				prv = bpLocs[k];
			}	
			sp = sp + "</tr></table>";
		}
		else
		{
			ci 		   = "";
			sp		   = "<table><tr><td style = 'font-size:10px;width: 406px;background-color:"+colorList[0]+"; color:"+fcolorList[0]+"'>1-"+siteCount+"</td></tr></table>";
		}
		htmlAICTable * ("\n<tr><td>"+ _partCount+ 
							  "</td><td><div style = 'width: "+100*currentAIC/byBPImprovement [0]$1+"%; background-color: purple; color: white;'>"+currentAIC+ 
							  "</div></td><td>"+ ci+ 
							  "</td><td>"+ sp+
							  "</td></tr>");
		
	}

	htmlAICTable * "\n</table></div>";
	htmlAICTable * 0;
	return htmlAICTable;
}

/*---------------------------------------------------------------------------------------------------------------------------------------------*/

function 	spoolKHTable (pairwiseP, bpLocations)
{
	
	readPCount		 = Rows (pairwiseP);
	totalComparisons = (readPCount-1)*2;
	threshP			 = 0.01/totalComparisons;
	
	bypvalue         = {{0.01, 0}{0.05, 0}{0.1, 0}} * (1/totalComparisons);
	
	
	
	colorList 	    = {{"red","orange","yellow"}};
	textColorList 	= {{"white","black","black"}};


	htmlAICTable = "";
	htmlAICTable * 128;


	htmlAICTable * "<p><b>KH testing report</b><div style = 'width: 580px; border: black dashed 1px; '>";
	htmlAICTable * ("<table style = 'width: 100%;font-size: 10px;text-align:left;'><tr>"+
					"<td>Breakpoint <span class = 'INFO' onmouseover = \"Tip('Location of the breakpoint')\">?</span></td>"+
					"<td>LHS p-value <span class = 'INFO' onmouseover = \"Tip('Adjusted KH p-value that the partition to the left of this BP has a topology different from the one inferred from the partition on the right ')\">?</span></td>"+
					"<td>RHS p-value<span class = 'INFO' onmouseover = \"Tip('Adjusted KH p-value that the partition to the right of this BP has a topology different from the one inferred from the partition on the left ')\">?</span></td>"+
					"<td>Signficance<span class = 'INFO' onmouseover = \"Tip('* for p-value of 0.1; ** for p-value of 0.05; *** for p-value of 0.01')\">?</span></td></tr>");
				   
	
	KHTestTables = {readPCount-1,2};
	
	for (pccounter = 1; pccounter <  readPCount; pccounter = pccounter + 1)
	{
		lhs     = pairwiseP[pccounter][pccounter-1];
		rhs     = pairwiseP[pccounter-1][pccounter];
							 
		sig = "";
		
		for (k = 0; k < Rows (bypvalue); k = k + 1)
		{
			threshP = bypvalue[k][0];
			if (lhs <= threshP && rhs <= threshP)
			{
				if (Abs (sig) == 0)
				{
					for (l = 3; l>k; l=l-1)
					{
						sig = sig + "*";
					}
				}
				
				bypvalue[k][1] = bypvalue[k][1] + 1;
			}
		}
		
		color = "transparent";
		bgColor = "black";
		if (Abs (sig) == 0)
		{
			sig = "N.S";
		}
		else
		{
			color = colorList[3-Abs (sig)];
			bgColor = textColorList[3-Abs(sig)];
		}
		
		KHTestTables [pccounter-1][0] = Min(1,lhs*totalComparisons);
		KHTestTables [pccounter-1][1] = Min(1,rhs*totalComparisons);
		
		htmlAICTable * ("\n<tr style='background-color:" + color + ";text-color:"+bgColor+"'><td>"+ Format(bpLocations[pccounter-1]+1,10,0)+ 
							  "</td><td>" + Format(Min(1,lhs*totalComparisons),14,5) + 
							  "</td><td>"+  Format(Min(1,rhs*totalComparisons),14,5) + 
							  "</td><td>"+ sig+
							  "</td></tr>");
		
	}
	

	htmlAICTable * "\n</table></div><dl>";

	for (k = 0; k < Rows (bypvalue); k = k + 1)
	{
		htmlAICTable * ("<dt>At p = " + bypvalue[k][0]*totalComparisons + " <dd>there are " + bypvalue[k][1] + " breakpoints with significant topological incongruence\n");
	}
	
	htmlAICTable * "</dl>";
	if (bypvalue [1][1] < readPCount-1)
	{
		htmlAICTable * ("<div class = 'ErrorTagSM'>KH-insignificant breakpoints arise most frequently due to variation in branch lengths between segments; this could be due to some forms of recombination or to other processes, such as spatial rate variation, heterotachy, etc.</div>");
		
	}
	
	htmlAICTable * 0;
	KHSupportedCount =  bypvalue[1][1];
	return htmlAICTable;
}

