/* UDS model processor script for datamonkey */


ExecuteAFile			("../Shared/HyPhyGlobals.ibf" );
ExecuteAFile 			("../Shared/GrabBag.bf");
ExecuteAFile 			("../Shared/ReadDelimitedFiles.bf");
ExecuteAFile			("../Shared/hiv_1_ref_sequences.ibf" );
ExecuteAFile 			("../Shared/DBTools.ibf" );
ExecuteAFile			("../Shared/DescriptiveStatistics.bf" );

drClasses = { { "PI", "NRTI", "NNRTI" } };

uploadPath 			= BASE_CLUSTER_ACCESS_PATH + filePrefix;
resName			= BASE_OUTPUT_PATH + filePrefix +"_" + suffix[kind] + ".php";
fprintf			(resName, CLEAR_FILE,"<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'><html><head><meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1'><meta http-equiv='refresh' content='60'>",
				"<title>Almost there...</title></head><body>Generating a UDS report...this page will refresh in a minute (or you can try sooner).");
spoolPATH 		= BASE_OUTPUT_PATH + filePrefix;

fprintf (stdout, "<script type='text/javascript' src='http://www.datamonkey.org/wz_tooltip.js'></script>\n<H1 CLASS='SuccessCap'>Ultradeep Sequence Analysis results</H1>\n");
sscanf (rawIn,"NMatrix,String,Number,Number,Number,Matrix,Matrix,Number", _in_gene_map, _in_score_matrix, _in_species, _in_gencode, _in_ref_option, _in_ref_names, _in_ref_sequences, _in_dodr );

numGenesProcessed = 0;
for ( _k = 0; _k < Rows ( _in_gene_map ); _k = _k + 1 ) {
	numGenesProcessed = numGenesProcessed + _in_gene_map [ _k ][ 0 ];
}



if ( numGenesProcessed == 0 ) {
	fprintf ( stdout, "<DIV class='RepClassSM'>No reads could be reliably aligned to the reference sequence</DIV>" );
	fprintf (stdout, "<DIV CLASS = 'RepClassSM'>Repeat the analysis with alternate parameters <a href='",BASE_CGI_URL_STRING,"UDS_launchQualityFilter.pl?filename=",filePrefix,"&genCodeID=",_in_gencode,"&method=99&sequences=",_in_species,"&skipQC=1&keys=",stringkey,"'>here</a>. <a href='",BASEL_URL_STRING,"help/uds.php' target = '_blank' class = 'INFO'>Help</a></DIV>");
}
else {

	fprintf ( stdout, "<DIV CLASS='RepClassCT'><b>Database reports</b> ");
	for ( _k = 0; _k < Rows ( _in_ref_names ); _k = _k + 1 ) {
		if ( _in_gene_map [ _k ][ 0 ] == 1 ) {
			dagene 	= _in_ref_names[_k][0];
			if ( _in_ref_option == 1 ) {
				dagene = (dagene^{{"HXB2_"}{""}})^{{"NL4_3"}{""}};
			}
			jobFileName = filePrefix + "_uds." + dagene + ".cache";
			fprintf ( stdout, "<a href='",BASE_CGI_URL_STRING,"downloadFile.pl?file=",jobFileName,"'>[",dagene,"]</a>" );
		}
	}
	fprintf ( stdout, "</DIV>" );

	/* fix this wayne
	stringkey = "";
	stringkey * 128;
	eersteEen = 1;
	for ( i = 0; i < Rows ( _in_gene_map ); i = i + 1 ) {
		if ( _in_gene_map [i] ) {	
			if ( eersteEen ) {
				stringkey * ( "" + i ); 
				eersteEen = 0;
			}
			else {
				stringkey * ( "," + i );
			}
		}
	}
	stringkey * 0;
	fprintf (stdout, "<DIV CLASS = 'RepClassSM'>Repeat the analysis with alternate parameters <a href='",BASE_CGI_URL_STRING,"UDS_launchQualityFilter.pl?filename=",filePrefix,"&genCodeID=",_in_gencode,"&method=99&sequences=",_in_species,"&skipQC=1&keys=",stringkey,"'>here</a>. <a href='",BASEL_URL_STRING,"help/uds.php' target = '_blank' class = 'INFO'>Help</a></DIV>");
	*/


	dbpath 	= spoolPATH + ".cache";
	DoSQL ( SQL_OPEN, dbpath, DBID );
    filestats = _ExecuteSQL (DBID, "SELECT * FROM UDS_FILE_INFO");
    filestats = filestats[0];
	DoSQL ( SQL_CLOSE, "", DBID );

	fprintf ( stdout, "<DIV class='RepClassSM'><b>Filtering of reads</b><br/><br/>The following reads were retained from the original data file (named <b>",filestats["Original"],"</b>), which contained <b>",filestats["Sequences"],"</b> reads.<br/><br/>" );
	fprintf ( stdout, "<TABLE BORDER='0' align='center'>" );
	fprintf ( stdout, "<TR CLASS = 'TRReport' style = 'font-size:small'><TH rowspan = '2'>Gene</TH><TH rowspan = '2'># reads</TH><TH colspan = '2'>Read length</TH><TH colspan = '2'>Coverage</TH><TH rowspan = '2'>Download</TH><TH colspan = '2' rowspan = '2'>Figures</TH></TR>" );
	fprintf ( stdout, "<TR CLASS = 'TRReport' style = 'font-size:small'><TH>Mean</TH><TH>Std. dev.</TH><TH>Mean</TH><TH>Std. dev. </TH></TR>" );

	printThreshWarning = 0;
	printError = 0;
	ct = 0;
	for ( _k = 0; _k < Rows ( _in_ref_names ); _k = _k + 1 ) {
		if ( _in_gene_map [ _k ][ 0 ] == 1 ) {
			dagene 	= _in_ref_names[_k][0];
			if ( _in_ref_option == 1 ) {
				dagene = (dagene^{{"HXB2_"}{""}})^{{"NL4_3"}{""}};
			}
			dbpath 	= spoolPATH + "_uds." + dagene + ".cache";
			pspath 	= BASE_HTML_URL_STRING + filePrefix + "_uds." + dagene + ".cache";
			DoSQL ( SQL_OPEN, dbpath, DBID );
	
			_recordsFound = {};
			DoSQL (DBID, "SELECT SPAN_PASS2 FROM SEQUENCES WHERE SPAN_PASS2 > 0", "return _matchRecordsByField (0);" );
			geneSequences = _recordsFound;
			
			_recordsFound = {};
			DoSQL (DBID, "SELECT EXP_PER_BASE_SCORE,THRESHOLD FROM SETTINGS", "return _matchRecordsByField (1);" );		
			expPerBase 	= 0 + (_recordsFound[0])["EXP_PER_BASE_SCORE"];
			thresh		= (0 + (_recordsFound[0])["THRESHOLD"])$1;
			
			
			
			addGeneLabel = "";
			if ( thresh < (5*expPerBase)$1 ) {
				printThreshWarning = 1;
				addGeneLabel = "*";
			}
			
			if ( Abs ( geneSequences ) ) {
				length_distro = { Abs ( geneSequences ), 1 };
				for ( _l = 0; _l < Abs ( geneSequences ); _l = _l + 1 ) {
					ExecuteCommands ( "length_distro[_l] = 0 + geneSequences[\"" + _l + "\"];" );
				}
				l_stats			 		= GatherDescriptiveStats (length_distro);
			
				_recordsFound = {};
				DoSQL (DBID, "SELECT COVERAGE FROM NUC_ALIGNMENT WHERE INDEL_POSITION = 0 ORDER BY POSITION", "return _matchRecordsByField (0);" );
				coverageInfo = _recordsFound;
				coverage_distro = { Abs ( coverageInfo ), 1 };
				for ( _l = 0; _l < Abs ( coverageInfo ); _l = _l + 1 ) {
					ExecuteCommands ( "coverage_distro[_l] = 0 + coverageInfo[\"" + _l + "\"];" );
				}
				c_stats			 		= GatherDescriptiveStats (coverage_distro);	
				fprintf ( stdout, "<TR CLASS='TRReport",(ct%2)+1,"' style = 'font-size:x-small'><TD>", addGeneLabel, dagene, "</TD><TD>", Abs(geneSequences), "</TD><TD>", Format(l_stats["Mean"],8,2), "</TD><TD>", Format(l_stats["Std.Dev"],8,2), "</TD><TD>", Format(c_stats["Mean"],8,2),"</TD><TD>", Format(c_stats["Std.Dev"],8,2), "</TD><TD><a href='",BASE_CGI_URL_STRING,"viewSequence.pl?file=",filePrefix,"&format=0&aligned=0&gene=",dagene,"'>[RAW_NUC]</a><a href='",BASE_CGI_URL_STRING,"viewSequence.pl?file=",filePrefix,"&format=1&aligned=0&gene=",dagene,"'>[RAW_AA]</a><a href='",BASE_CGI_URL_STRING,"viewSequence.pl?file=",filePrefix,"&format=0&aligned=1&gene=",dagene,"'>[ALGN_NUC]</a></TD><TD><a href='",pspath,"_coverage.ps'>[COVERAGE]</a></TD><TD><a href='",pspath,"_majority.ps'>[MAJORITY PROP]</a></TD></TR>" );
			}
			else {
				fprintf ( stdout, "<TR CLASS='TRReport",(ct%2)+1,"' style = 'font-size:x-small'><TD>", dagene, "</TD><TD>N/A</TD><TD>N/A</TD><TD>N/A</TD><TD>N/A</TD><TD>N/A</TD><TD>N/A</TD><TD>N/A</TD><TD>N/A</TD></TR>" );
				printError = 1;
			}
			ct = ct + 1;
			DoSQL ( SQL_CLOSE, "", DBID );
		}
	}
	fprintf ( stdout, "</TABLE><br/>" );
	if ( printError ) {
		fprintf ( stdout, "<br/><TABLE><tr CLASS='TRReportNT'><td align = \"left\"><b>N/A: </b></td><td align = \"left\">No reads met the minimum coverage and length requirements.</td></tr></TABLE>" );
	}
	if ( printThreshWarning ) {
		fprintf ( stdout, "<DIV CLASS = 'ErrorTagSM'><b>WARNING</b>: Reference genes labeled with a * indicate analyses for which the per base alignment score threshold used did not exceed 5 times the expected score. This may be due to an innapropriate reference sequence. See <a href='",BASEL_URL_STRING,"help/uds.php' class = 'INFO'>HELP</a> for more information.</DIV>" );
	}
	fprintf ( stdout, "</DIV>" );

	


	/*get the  diversity results*/
	ct = 0;
	printError = 0;
	for ( _k = 0; _k < Rows ( _in_ref_names ); _k = _k + 1 ) {
		if ( _in_gene_map [ _k ][ 0 ] ) {
			dagene 	= _in_ref_names[_k][0];
			if ( _in_ref_option == 1 ) {
				dagene = (dagene^{{"HXB2_"}{""}})^{{"NL4_3"}{""}};
			}
			dbpath 	= spoolPATH + "_uds." + dagene + ".cache";
			DoSQL ( SQL_OPEN, dbpath, DBID );
		
			_recordsFound = {};
			DoSQL ( DBID, "SELECT * FROM SETTINGS", "return _matchRecordsByField (1);" );
			_analysisSettings = _recordsFound;
		
			if ( ct == 0 ) {/*print the settings*/
				fprintf ( stdout, "<DIV class='RepClassSM'><b>Sliding window analysis of maximum divergence</b><br/><br/>" );
				fprintf ( stdout, "The maximum diverence between two tips in a tree was estimated in sliding windows of width = ", (_analysisSettings[0])["SW_SIZE"], ", stride = ", (_analysisSettings[0])["SW_STRIDE"], " and at which the minumum coverage was ", (_analysisSettings[0])["MIN_COVERAGE"], ". The sliding windows with maximum diversity are reported below, and detailed reports with all sliding windows are also available.<br/><br/>" );
				fprintf ( stdout, "<TABLE BORDER='0' align='center'>" );
				fprintf ( stdout, "<TR CLASS = 'TRReport' style = 'font-size:small'><TH>Gene</TH><TH># sliding windows</TH><TH>max divergence</TH><TH>max divergence window</TH><TH>detailed report</TH></TR>" );
			}
		
			_recordsFound = {};
			DoSQL ( DBID, "SELECT * FROM DIVERSITY_SW", "return _matchRecordsByField (0);" );
			swSummary = _recordsFound;
		
			if ( Abs ( swSummary ) ) {
				fprintf ( stdout, "<TR CLASS='TRReport",(ct%2)+1,"' style = 'font-size:x-small'><TD>", dagene, "</TD><TD>", (swSummary[0])["NUM_WINDOWS"], "</TD><TD>", (swSummary[0])["MAX_DIVERGENCE"], "</TD><TD>", (swSummary[0])["MAX_DIVERGENCE_WINDOW"], "</TD><TD><a href='",BASE_CGI_URL_STRING,"udsReport.pl?file=",filePrefix,"&report_type=0&gene=",dagene,"'>[report]</a></TD></TR>" );
			}
			else {		
				fprintf (stdout, "<TR CLASS='TRReport",(ct%2)+1,"' style = 'font-size:x-small'><TD>", dagene, "</TD><TD>N/A</TD><TD>N/A</TD><TD>N/A</TD><TD>N/A</TD></TR>" );
				printError = 1;
			}
			ct = ct + 1;
			DoSQL ( SQL_CLOSE, "", DBID );
		}
	}
	fprintf ( stdout, "</TABLE>" );
	if ( printError ) {
		fprintf ( stdout, "<br/><TABLE><tr CLASS='TRReportNT'><td align = \"left\"><b>N/A: </b></td><td align = \"left\">No reads met the minimum coverage and sliding window requirements.</td></tr></TABLE>" );
	}
	fprintf ( stdout, "</DIV>" );

	/*report the mutation rate classes detected with binomial mixture model */

	fprintf ( stdout, "<DIV class='RepClassSM'><b>Mutation rate classes</b><br/><br/>" );
	fprintf ( stdout, "The number of mutation rate classes is estimated using a binomial mixture model. Briefly, we fit a model with a single rate class and estimate the mutation rate from a binomial distribution with the number of successes equal to the number of observed mutations at a site, and the number of trials equal to the observed coverage at a site. Additional rate classes are added using a mixture of binomial models until model fit (evaluated using AIC) is no longer improved. The parameters of the binomial mixture model (i.e. rates and their respective proportions) are estimated using maximum likelihood. See <a href='http://en.wikipedia.org/wiki/Binomial_distribution'>Wikipedia</a> for more information on the binomial distribution.<br/><br/>" );
	fprintf ( stdout, "</div>" );
			
	for ( _k = 0; _k < Rows ( _in_ref_names ); _k = _k + 1 ) {
		if ( _in_gene_map [ _k ][ 0 ] ) {
			dagene 	= _in_ref_names[_k][0];
			if ( _in_ref_option == 1 ) {
				dagene = (dagene^{{"HXB2_"}{""}})^{{"NL4_3"}{""}};
			}
			dbpath 	= spoolPATH + "_uds." + dagene + ".cache";
			DoSQL ( SQL_OPEN, dbpath, DBID );
		
			_recordsFound = {};
			DoSQL ( DBID, "SELECT * FROM MU_RATE_CLASSES", "return _matchRecordsByField (0);" );
			mu_rate_classes = _recordsFound;
		
			if ( Abs ( mu_rate_classes ) ) {
				maxRate = 0 + (mu_rate_classes[Abs(mu_rate_classes)-1])["NUM_RATES"];
				for ( _l = 0; _l < maxRate-1; _l = _l + 1 ) {
			
					if ( _l == 0 ) {
						fprintf ( stdout, "<DIV class='RepClassSM'>Sitewise mutation analysis: ", dagene, " <a href='",BASE_CGI_URL_STRING,"udsReport.pl?file=",filePrefix,"&report_type=1&gene=",dagene,"'>[HTML]</a><a href='",BASE_CGI_URL_STRING,"udsReport.pl?file=",filePrefix,"&report_type=1&gene=",dagene,"&outmode=1' target = '_blank'>[CSV]</a><br/><br/>" );
						fprintf ( stdout, "<TABLE BORDER='0' align='center'>" ); 
						fprintf ( stdout, "<TR CLASS = 'TRReport' style = 'font-size:small'><TH># ", dagene ," rate classes</TH><TH>mutation rates</TH><TH>proportions</TH><TH>log lk</TH><TH>AIC</TH></TR>" );
					}
		
					_recordsFound = {};
					DoSQL ( DBID, "SELECT * FROM MU_RATE_CLASSES WHERE NUM_RATES='" + (_l+1) + "'", "return _matchRecordsByField (0);" );
					rateClassAVL = _recordsFound;
		
					rateString = "";
					rateString * 128;
					propString = "";
					propString * 128;
					for ( _m = 0; _m < Abs ( rateClassAVL ); _m = _m + 1 ) {
						if ( _m == 0 ) {
							rateString * ( "" + Format ( 0 + (rateClassAVL[_m])["MU_RATE"], 2, 4 ) );
							propString * ( "" + Format ( 0 + (rateClassAVL[_m])["WEIGHT"], 2, 2 ) );
						}
						else {
							rateString * ( "; " + Format ( 0 + (rateClassAVL[_m])["MU_RATE"], 2, 4 ) );
							propString * ( "; " + Format ( 0 + (rateClassAVL[_m])["WEIGHT"], 2, 2 ) );
						}		
					}
					rateString * 0;
					propString * 0;
			
					fprintf ( stdout, "<TR CLASS='TRReport",(_l%2)+1,"' style = 'font-size:x-small'><TD>", (_l+1), "</TD><TD>", rateString, "</TD><TD>", propString, "</TD><TD>", (rateClassAVL[0])["LOG_LK"], "</TD><TD>", (rateClassAVL[0])["AIC"], "</TD></TR>" );
				}	
		
				fprintf ( stdout, "</TABLE><br/>" );
				_recordsFound = {};
				DoSQL ( DBID, "SELECT * FROM MU_RATE_CLASSES WHERE AIC=(SELECT min(AIC) FROM MU_RATE_CLASSES) limit 1", "return _matchRecordsByField (0);" );
				_bestAIC = _recordsFound;
				fprintf ( stdout, "Best model fit was with ", (_bestAIC[0])["NUM_RATES"], " rate classes where AIC = ", (_bestAIC[0])["AIC"], ". The minimum mutation rate of " );
				_recordsFound = {};
				DoSQL ( DBID, "SELECT * FROM MU_RATE_CLASSES WHERE MU_RATE=(SELECT min(MU_RATE) FROM MU_RATE_CLASSES WHERE NUM_RATES=" + (_bestAIC[0])["NUM_RATES"] + ")", "return _matchRecordsByField (0);" );
				fprintf ( stdout, (_recordsFound[0])["MU_RATE"] , " corresponds to a background rate and can be used as an estimation of 454 error rate given the observed alignment and coverage." );
		
				if ( maxRate != 2 ) {
					fprintf ( stdout, "</br></br>Alternatively, we utilize an empirical Bayesian approach to estimate the posterior probability of each site belonging to each of the <b>", (maxRate-1), "</b> rate classes.<br/></br>" );
					fprintf ( stdout, "<a href='",BASE_CGI_URL_STRING,"udsReport.pl?file=",filePrefix,"&report_type=4&gene=",dagene,"'>[POSTERIORS_HTML]</a><a href='",BASE_CGI_URL_STRING,"udsReport.pl?file=",filePrefix,"&report_type=4&gene=",dagene,"&outmode=1' target = '_blank'>[POSTERIORS_CSV]</a>" );
				}
				fprintf ( stdout, "</DIV>" );		
			}
			else {
				fprintf ( stdout, "<DIV class='RepClassSM'>No reads met the minimum coverage and length requirements for ", dagene, "</DIV>" );
			}
		
			DoSQL ( SQL_CLOSE, "", DBID );
		}
	}

	/*report the drug resistance results if there are rt, pr or pol genes */
	ct = 0;
	printError = 0;
	for ( _k = 0; _k < Rows ( _in_ref_names ); _k = _k + 1 ) {
		if ( _in_gene_map [ _k ][0] && _in_gene_map [ _k ][1] ) {
			dagene 	= _in_ref_names[_k][0];
			if ( _in_ref_option == 1 ) {
				dagene = (dagene^{{"HXB2_"}{""}})^{{"NL4_3"}{""}};
			}
			dbpath 	= spoolPATH + "_uds." + dagene + ".cache";
			DoSQL ( SQL_OPEN, dbpath, DBID );
		
			_recordsFound = {};
			DoSQL ( DBID, "SELECT * FROM SETTINGS", "return _matchRecordsByField (0);" );
			_analysisSettings = _recordsFound;
		
			if ( ct == 0 ) {/*print the settings*/
				fprintf ( stdout, "<DIV class='RepClassSM'><b>Drug Resistant Mutation Analyses</b><br/><br/>" );
				fprintf ( stdout, "Stanford Drug resistant mutations with scores >= ", (_analysisSettings[0])["STANFORD_SCORE"], " and coverage >= ", (_analysisSettings[0])["MIN_DR_COVERAGE"], " were identified from the reads. For each drug resistant site we estimate the mutation rank (i.e. the rank of the mutation rate with respect to all other sites) and calculate the median mutation rank of all drug resistant sites. We utilize a permutation test (n=1000) to determine whether the observed median mutation rank for drug resistant sites is significantly greater (P<0.05) than an equivalent-sized sample of non-drug resistant sites. These data can be used to determine if mutation properties at drug resistant sites are unique.<br/><br/>" );
				fprintf ( stdout, "<TABLE BORDER='0' align='center'>" );
				fprintf ( stdout, "<TR CLASS = 'TRReport' style = 'font-size:small'><TH>Gene</TH><TH>drug class</TH><TH>median mutation rank</TH><TH>P</TH><TH>detailed report</TH></TR>" );
			}
		
			_recordsFound = {};
			DoSQL ( DBID, "SELECT * FROM MDR_SUMMARY", "return _matchRecordsByField (0);" );
			mdr_summary = _recordsFound;
		
			if ( Abs ( mdr_summary ) ) {
				for ( _l = 0; _l < Abs ( mdr_summary ); _l = _l + 1 ) {
					if ( ( 0 + (mdr_summary[_l])["MEDIAN_MUT_RNK"] ) != 0 ) {
						fprintf ( stdout, "<TR CLASS='TRReport",(ct%2)+1,"' style = 'font-size:x-small'><TD>", dagene, "</TD><TD>", (mdr_summary[_l])["DRUG_CLASS"],"</TD><TD>", (mdr_summary[_l])["MEDIAN_MUT_RNK"], "</TD><TD>", (mdr_summary[_l])["P_VALUE"], "</TD><TD><a href='",BASE_CGI_URL_STRING,"udsReport.pl?file=",filePrefix,"&report_type=2&gene=",dagene,"&dc=",(mdr_summary[_l])["DRUG_CLASS"],"'>[report]</a></TD></TR>" );
						ct = ct + 1;
					}
				}
			}
			else {
				fprintf ( stdout, "<TR CLASS='TRReport",(ct%2)+1,"' style = 'font-size:x-small'><TD>", dagene, "</TD><TD>N/A</TD><TD>N/A</TD><TD>N/A</TD><TD>N/A</TD></TR>" );
				printError = 1;
				ct = ct + 1;
			}
		
			DoSQL ( SQL_CLOSE, "", DBID );
		}
	}
	if ( ct != 0 ) {
		fprintf ( stdout, "</TABLE>" ); 
		if ( printError ) {
			fprintf ( stdout, "<br/><TABLE><tr CLASS='TRReportNT'><td align = \"left\"><b>N/A: </b></td><td align = \"left\">No reads met the minimum coverage requirements.</td></tr></TABLE>" );
		}
		fprintf ( stdout, "</DIV>" ); 
	}


	/*compensatory mutation results*/
	ct = 0;
	printError = 0;
	for ( _k = 0; _k < Rows ( _in_ref_names ); _k = _k + 1 ) {
		if ( _in_gene_map [ _k ][0] && _in_gene_map [ _k ][1] ) {
			dagene 	= _in_ref_names[_k][0];
			if ( _in_ref_option == 1 ) {
				dagene = (dagene^{{"HXB2_"}{""}})^{{"NL4_3"}{""}};
			}
			dbpath 	= spoolPATH + "_uds." + dagene + ".cache";
			DoSQL ( SQL_OPEN, dbpath, DBID );

			_recordsFound = {};
			DoSQL ( DBID, "SELECT (DR_ACC+NOTDR_ACC+DR_NOTACC+NOTDR_NOTACC) FROM ACCESSORY_TEST", "return _matchRecordsByField(0);" );
			totalReads = 0 + _recordsFound[0];
		
			_recordsFound = {};
			DoSQL ( DBID, "SELECT * FROM ACCESSORY_TEST", "return _matchRecordsByField(0);" );
			accCounts =  _recordsFound;
		
			if ( totalReads > 0 ) {
				if ( ct == 0 ) {
					fprintf ( stdout, "<DIV class='RepClassSM'><b>Compensatory Drug Resistant Mutation Analyses</b><br/><br/>" );
					fprintf ( stdout, "Ultradeep sequence reads were screened for the presence of compensatory drug resistant mutations. A Fisher's Exact Test is used to determine whether these compensatory mutations occur in association with known drug resistant mutations more or less frequently than expected by chance.<br/><br/>" );
					fprintf ( stdout, "<TABLE BORDER='0' align='center'>" );
					fprintf ( stdout, "<TR CLASS='TRReport' style='font-size:small'><TH>Gene</TH><TH>dr_acc</TH><TH>notdr_acc</TH><TH>dr_notacc</TH><TH>notdr_notacc</TH><TH>P</TH><TH>detailed report</TH></TR>" );			
				}
				fprintf ( stdout, "<TR CLASS='TRReport",(ct%2)+1,"' style = 'font-size:x-small'><TD>", dagene, "</TD><TD>", (accCounts[0])["DR_ACC"], "</TD><TD>", (accCounts[0])["NOTDR_ACC"], "</TD><TD>", (accCounts[0])["DR_NOTACC"], "</TD><TD>", (accCounts[0])["NOTDR_NOTACC"], "</TD><TD>", (accCounts[0])["P_VAL"], "</TD><TD><a href='",BASE_CGI_URL_STRING,"udsReport.pl?file=",filePrefix,"&report_type=5&gene=",dagene,"'>[report]</a></TD><TR>" );
				ct = ct + 1;
			}
			DoSQL ( SQL_CLOSE, "", DBID );
		}
	}
	if ( ct != 0 ) {
		fprintf ( stdout, "</TABLE><br/>" ); 
		fscanf ( "../Formats/uds_report_comp", "Raw", _legend );
		fprintf ( stdout, _legend, "</DIV>" );
	}
}

function PrintDescriptiveStats_HTMLRow (label, _stats, printHeader, RowHeader )
{
	if ( printHeader ) {
		fprintf ( stdout, "<TABLE BORDER='0' align='center'>" );
		fprintf ( stdout, "<TR CLASS = 'TRReport' style = 'font-size:small'>" );
		fprintf ( stdout, "<th>", RowHeader, "</th><th>mean</th><th>median</th><th>variance</th><th>sd</th><th>min</th><th>2.5%</th><th>97.5%</th><th>max</th>" );
		fprintf ( stdout, "</TR>" );
	}
	fprintf ( stdout, "<TR><td>", label, "</td><td>", _stats["Mean"], "</td><td>", _stats["Median"], "</td><td>", _stats["Variance"], "</td><td>", _stats["Std.Dev"], "</td><td>", _stats["Min"], "</td><td>", _stats["2.5%"], "</td><td>", _stats["97.5%"], "</td><td>", _stats["max"], "</td><td></tr>" );

	return 0;
}