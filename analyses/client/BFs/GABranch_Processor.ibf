function convertMatrixToBranchPart (daModel){	matchedRateAVL = {};	for (k=0; k<Columns(branchNames)-1; k=k+1)	{		nodeRate  = daModel[k];		existingString = matchedRateAVL[nodeRate];		if (Abs(existingString))		{			existingString = existingString+",\""+branchNames[k]+"\"";				}		else		{			existingString = "\""+branchNames[k]+"\"";		}		matchedRateAVL[nodeRate] = existingString;	}	matchedRateKeys = Rows (matchedRateAVL);		convMdlString = "";	convMdlString * 128;	convMdlString * ("Tree theTree = "+Format (analysisTree,1,0) + ";\n_branchClasses={};\n");		for (k=0; k<Abs(matchedRateAVL); k=k+1)	{		daKey = matchedRateKeys[k];		convMdlString * ("_branchClasses[\""+daKey+"\"]={{"+matchedRateAVL[daKey]+"}};\n");	}		convMdlString * 0;	return convMdlString;}/*----------------------------------------------------------------------------------*/branchLabels = {};inFilePath			= BASE_OUTPUT_PATH + filePrefix;	fPath 				= inFilePath;relativeURL  = inFilePath $ "/[^/]+$";h = relativeURL[0];relativeURL = inFilePath[h+1][Abs(inFilePath)-1];fName			= fPath + ".raw";fprintf 		(fName, CLEAR_FILE, rawIn);fprintf			(fPath, CLEAR_FILE,"<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'><html><head><meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1'><meta http-equiv='refresh' content='300'><title>Almost there...</title></head><body>Generating a report...this page will refresh in 5 minutes (or you can try sooner).</body></html>");sscanf			(rawIn,"Tree",analysisTree);branchCount = TipCount (analysisTree) + BranchCount (analysisTree);branchNames = BranchName (analysisTree,-1);sscanf			(rawIn,"Number",treeMode);modelScores    = {};branchMatrices = {};while (!END_OF_FILE){	branchRates = 0;	sscanf (rawIn, "Number,NMatrix", maic, branchRates);	if (Abs(branchRates) == 0)	{		break;	}	modelScores[Abs(modelScores)] = maic;	branchMatrices[Abs(branchMatrices)] = branchRates;}rawIn 			= 0;modelCount 		= Abs(modelScores);bestAIC	   		= 1e100;modelAICs  		= {modelCount,1};branchRates 	= {branchCount, modelCount}["1"];byRate 		     = {};bestAICByRate    = {};bestRateByClass  = {};rateCountByModel = {1,modelCount};for (h=0; h<modelCount; h=h+1){	maic 			= modelScores[h];	branchMatrix 	= branchMatrices[h];		if (maic<bestAIC)	{		bestAIC 	= 	maic;		bestModel 	= 	branchMatrix;	}		rateAVL = {};	for (v2=0; v2<branchCount;v2=v2+1)	{		branchRates[v2][h]        = branchMatrix[v2];		rateAVL[branchMatrix[v2]] = rateAVL[branchMatrix[v2]]+1;	}		rateC  		 = Abs(rateAVL);	if (bestAICByRate[rateC] == 0)	{		bestAICByRate[rateC]   = maic;		bestRateByClass[rateC] = rateAVL;	}	else	{		if (maic < bestAICByRate[rateC])		{			bestAICByRate[rateC] = maic;			bestRateByClass[rateC] = rateAVL;		}	}	rateCountByModel [h] = rateC;	byRate 		 [rateC] = byRate [rateC] + 1;	modelAICs[h] 		 = maic;}sAICs = modelAICs;modelScores    = 0;branchMatrices = 0;normalizer = 0;for (h=0; h<modelCount; h=h+1){	modelAICs[h] = Exp(-(modelAICs[h]-bestAIC)*0.5);	normalizer = normalizer+modelAICs[h];}modelAICs = modelAICs * (1/normalizer); summaryMatrix = {branchCount,6};pairwiseSame  = {branchCount,branchCount};overOne		  = {branchCount,1};for (h=0; h<branchCount; h=h+1){	probabilityMatrix = {modelCount,2};	for (v=0; v<modelCount; v=v+1)	{		probabilityMatrix[v][0] = branchRates[h][v];		probabilityMatrix[v][1] = modelAICs[v];	}	probabilityMatrix = probabilityMatrix%0;		sum  = 0;	sum2 = 0;	prob = 0;	r25  = -1;	r975 = -1;	r500	 = -1;	overOne = 0;		for (v=0; v<modelCount; v=v+1)	{		mpp = probabilityMatrix[v][1];		mpv = probabilityMatrix[v][0];				sum = sum + mpv * mpp;		sum2 = sum2 + mpv^2 * mpp;		prob = prob + mpp;				if (mpv>1)		{			overOne = overOne+mpp;		}				if (prob > 0.025 && r25 < 0)		{			r25 = probabilityMatrix[v][0];		}		if (prob > 0.975 && r975 < 0)		{			r975 = probabilityMatrix[v][0];		}		if (prob >= 0.5 && r500 < 0)		{			r500 = probabilityMatrix[v][0];		}	}		summaryMatrix[h][0] = sum;	summaryMatrix[h][1] = Sqrt(sum2-sum^2);	summaryMatrix[h][2] = r25;	summaryMatrix[h][3] = r975;	summaryMatrix[h][4] = overOne;	summaryMatrix[h][5] = r500;}for (h=0; h<branchCount; h=h+1){	for (v=h+1; v<branchCount; v=v+1)	{		for (v2 = 0; v2 < modelCount; v2 = v2+1)		{			if (branchRates[h][v2] == branchRates[v][v2])			{				pairwiseSame[h][v] = pairwiseSame[h][v] + modelAICs[v2];				pairwiseSame[v][h] = pairwiseSame[h][v];			}		}	}}probabilityMatrix = {modelCount,2};inCSByRates		  = {};for (v=0; v<modelCount; v=v+1){	probabilityMatrix[v][0] = v;	probabilityMatrix[v][1] = modelAICs[v];}probabilityMatrix = probabilityMatrix % 1;runSum 			  = 0;for (v=modelCount-1; v>=0 && runSum < 0.95; v=v-1){	runSum = runSum + probabilityMatrix[v][1];	inCSByRates [rateCountByModel[probabilityMatrix[v][0]]] = inCSByRates [rateCountByModel[probabilityMatrix[v][0]]] + 1;}csSize = modelCount-v-1;fprintf (stdout, "<H1 CLASS='SuccessCap'>GA-branch analysis results</H1>",_makeJobIDHTML(filePrefix));fprintf (stdout, "<DIV class = 'RepClassSM' style = 'max-width: 100%'>Small sample AIC (c-AIC) scores by class (best score in bold)<p>");htmlAICTable = "";htmlAICTable * 128;htmlAICTable * "<div style = 'width: 580px; border: black solid 1px; '>";htmlAICTable * "<table style = 'width: 100%;font-size: 10px;text-align:left;'><tr><th>Rates</th><th>c-AIC</th><th>&Delta; c-AIC</th><th width = '70%'>dN/dS by class (# branches)</th></tr>";currentAIC = bestAICByRate [1];for (_partCount = 1; _partCount <=Abs (byRate); _partCount = _partCount + 1){	bpLocs2    = bestRateByClass		 [_partCount];	if (_partCount>1)	{		currentAIC = bestAICByRate [_partCount];		ci 		   = bestAICByRate [_partCount-1] - currentAIC;		sp		   = "<table style = 'padding: 0px; spacing: 0px;'><tr>";				rts = Rows (bestRateByClass[_partCount]);		for (k=0; k<Abs (bpLocs2); k=k+1)		{			sp = sp + "<td style = 'font-size:10px;'>" + rts[k] + "(" + bpLocs2[rts[k]] + ")</td>";		}			sp = sp + "</tr></table>";	}	else	{		ci 		   = "";		rts = Rows (bestRateByClass[_partCount]);		sp		   = "<table><tr><td style = 'font-size:10px;width: 406px;'>"+rts[0] + "(" + bpLocs2[rts[0]] + ")</td></tr></table>";	}	if (currentAIC == bestAIC)	{		modS = " style='font-weight: 900; font-size:14px;'";		bestRates  = _partCount;		bestDelta  = bestAICByRate [1] - bestAICByRate [_partCount];	}	else	{		modS = "";	}	htmlAICTable * ("\n<tr" + modS+ "><td>"+ _partCount+ 						  "</td><td><div style = 'width: "+100*currentAIC/bestAICByRate [1]$1+"%; background-color: purple; color: white;'>"+currentAIC+ 						  "</div></td><td>"+ ci+ 						  "</td><td>"+ sp+						  "</td></tr>");	}htmlAICTable * "\n</table></div>";htmlAICTable * 0;GABranch_SummaryTable = {};GABranch_SummaryTable ["COL_KEY"] 	 = "STRING";GABranch_SummaryTable ["COL_VALUE"]  = "STRING";_CheckDBID 		  (slacDBID,"GAB_SUMMARY",GABranch_SummaryTable);record ={};record ["COL_KEY"] = "Rates";record ["COL_VALUE"] = bestRates;_InsertRecord (slacDBID,"GAB_SUMMARY", record);record ["COL_KEY"] = "Improvement";record ["COL_VALUE"] = bestDelta;_InsertRecord (slacDBID,"GAB_SUMMARY", record);record ["COL_KEY"] = "TreeMode";record ["COL_VALUE"] = treeMode;_InsertRecord (slacDBID,"GAB_SUMMARY", record);fprintf (stdout, htmlAICTable,"<p>95% Confidence Set of Models<p>");htmlAICTable = "";htmlAICTable * 128;htmlAICTable * "<div style = 'width: 580px; border: black solid 1px; '>";htmlAICTable * "<table style = 'width: 100%;font-size: 10px;text-align:left;'><tr style = 'width: 20%'><th>Rates</th><th>Models in 95% CS</th></tr>";for (_partCount = 1; _partCount <=Abs (byRate); _partCount = _partCount + 1){	htmlAICTable * ("<tr><td>" + _partCount + "</td><td>" + inCSByRates[_partCount] + "</td></tr>\n");}htmlAICTable * "\n</table></div>";htmlAICTable * 0;fprintf (stdout, htmlAICTable,"</DIV>");outString = "";outString * 8192;outString2 = "";outString2 * 8192;outString * "Branch Name,Mean,Std.Dev.,2.5%,Median,97.5%,Prob{dN>dS}\n";outString2 * "<TR style = 'color: white; font-size: small; font-family: times;background-color: #444444; text-align: right;  padding:5px;'><TH>Branch Name</TH><TH>Mean</TH><TH>Std.Dev.</TH><TH>2.5%</TH><TH>Median</TH><TH>97.5%</TH><TH>Prob{dN&gt;dS}&#134;</TH><TH>Density</TH></TR>\n";for (h=0; h<branchCount; h=h+1){	outString * (branchNames[h] + "," + summaryMatrix[h][0]+ "," + summaryMatrix[h][1]+ "," + summaryMatrix[h][2]+ "," + summaryMatrix[h][5]+ "," + summaryMatrix[h][3]+"," + summaryMatrix[h][4]+"\n");	if (h%2)	{		outString2 * ("<TR CLASS = 'TRReport2' style = 'font-size:11px'>");	}	else	{		outString2 * ("<TR CLASS = 'TRReport1' style = 'font-size:11px'>");	}	if (summaryMatrix[h][4]>=0.95)	{		outString2 * ("<TD ALIGN = 'LEFT'><b>"+branchNames[h]+"</b></TD><TD>"+Format (summaryMatrix[h][0],10,3)+"</TD><TD>"+Format (summaryMatrix[h][1],10,3)+"</TD><TD>"+Format (summaryMatrix[h][2],10,3)+"</TD><TD>"+Format (summaryMatrix[h][5],10,3)+"</TD><TD>"+					  	 Format (summaryMatrix[h][3],10,3)+"</TD><TD><b>"+Format (summaryMatrix[h][4],10,3)+"</b></TD><TD><a href = '" + BASE_CGI_URL_STRING + "gabranch_ratedistro.pl?file="+filePrefix+"&branch="+h+"&branchName="+branchNames[h]+"&mode=0' target = '_blank'><IMG SRC = 'http://www.hyphy.org/images/histogram_icon.gif' WIDTH = '27' HEIGHT = '29' BORDER = '0' ALT = 'dN/dS PDF'></TD></TR>\n");	}	else	{		outString2 * ("<TD ALIGN = 'LEFT'>"+branchNames[h]+"</TD><TD>"+Format (summaryMatrix[h][0],10,3)+"</TD><TD>"+Format (summaryMatrix[h][1],10,3)+"</TD><TD>"+Format (summaryMatrix[h][2],10,3)+"</TD><TD>"+Format (summaryMatrix[h][5],10,3)+"</TD><TD>"+					  	 Format (summaryMatrix[h][3],10,3)+"</TD><TD>"+Format (summaryMatrix[h][4],10,3)+"</TD><TD><a href = '" + BASE_CGI_URL_STRING + "gabranch_ratedistro.pl?file="+filePrefix+"&branch="+h+"&branchName="+branchNames[h]+"&mode=0' target = '_blank'><IMG SRC = 'http://www.hyphy.org/images/histogram_icon.gif' WIDTH = '27' HEIGHT = '29' BORDER = '0' ALT = 'dN/dS PDF'></TD></TR>\n");		}}outString * 0;outString2 * 0;fName = fPath + "_branch_rates.csv";fprintf (fName, CLEAR_FILE,outString);fprintf (stdout, "<DIV CLASS = 'RepClassSM' style = 'max-width: 100%'>Model Averaged Branch dN/dS [Get a <a href = '",relativeURL,"_branch_rates.csv'>.csv</a> version]<p>Branches with high model-averaged support for dN&gt;dS are shown in <b>bold</b>",				 "<p>Get a [<a href = '",relativeURL,"_branch_equal.csv'>.csv table</a>] of model averaged probabilities that any two branches have the same dN/dS.",				 "<p><TABLE BORDER = '0' WIDTH = '100%'>",outString2,"</TABLE>",				 "<font size = '-1'><br>&#134; Note: not a p-value!</font></DIV>");outString = "";outString * 8192;outString * "Branch Name";for (h=0; h<branchCount; h=h+1){	outString * (","+branchNames[h]);}for (h=1; h<branchCount; h=h+1){	outString * ("\n"+branchNames[h]);	for (h2=0; h2<branchCount; h2=h2+1)	{		outString * (","+pairwiseSame[h][h2]);	}}outString * 0;fName = fPath + "_branch_equal.csv";fprintf (fName, CLEAR_FILE,outString);branchColors  = {};branchLabels  = {};branchRates   = {};branchLengths = {};branchColors [0] = {{0,128,0}}*(1/255);   		/* clover */branchColors [1] = {{255,0,0}}*(1/255); 		/* red */branchColors [2] = {{64,0,128}}*(1/255); 		/* eggplant */branchColors [3] = {{0,0,255}}*(1/255);   		/* blue */branchColors [4] = {{200,200,200}}*(1/255);   	/* light gray */branchColors [5] = {{0,64,0}}*(1/255);   		/* clover */branchColors [6] = {{128,0,0}}*(1/255); 		/* red */branchColors [7] = {{32,0,64}}*(1/255); 		/* eggplant */branchColors [8] = {{0,0,128}}*(1/255);   		/* blue */branchColors [9] = {{100,100,100}}*(1/255);   	/* light gray */TREE_OUTPUT_OPTIONS = {};tree_lng = BranchLength (analysisTree,-1);totalTreeLength = 0;iNodeCounter = 1;for (k=0; k<Columns(branchNames)-1; k=k+1){	nodeSpec  = {};	nodeName  = branchNames [k]&&1;	nodeLabel = branchLabels[nodeName];	if (Abs(nodeLabel))	{		nodeSpec ["TREE_OUTPUT_BRANCH_LABEL"] = "("+nodeLabel+") show";	}	else	{		if (nodeName/"NODE*")		{			nodeSpec ["TREE_OUTPUT_BRANCH_LABEL"] = "__FONT_SIZE__ 3 idiv -__FONT_SIZE__ 3 idiv rmoveto\n("+nodeName+") show";			iNodeCounter = iNodeCounter + 1;		}	}	nodeRate  = bestModel[k];	nodeColor = branchRates[nodeRate];	if (Abs(nodeColor) == 0)	{		branchRates[nodeRate] = Abs(branchRates)+1;	}	nodeColor = branchRates[nodeRate]-1;	branchLengths [nodeRate] = branchLengths [nodeRate] + tree_lng[k];	totalTreeLength = totalTreeLength + tree_lng[k];	nodeSpec ["TREE_OUTPUT_BRANCH_COLOR"] = branchColors[nodeColor%Abs(branchColors)];	nodeSpec ["TREE_OUTPUT_OVER_BRANCH"] = "0 0 0 setrgbcolor\n5 5 rmoveto\n("+Format(summaryMatrix[k][4]*100,0,1)+"\\%) show";	nodeName  = branchNames [k];	TREE_OUTPUT_OPTIONS[nodeName] = nodeSpec;}baseHeight = TipCount (analysisTree)*48;TREE_OUTPUT_OPTIONS["__FONT_SIZE__"] = 16;psString = PSTreeString (analysisTree,"",{{612,baseHeight}});psLegend = "";psLegend * 256;bKeys = Rows (branchRates);sortedKeys = {Abs(branchRates),2};for (k=0; k<Abs(branchRates); k=k+1){	sortedKeys[k][0] = 0+bKeys[k];	sortedKeys[k][1] = k;}	sortedKeys = sortedKeys%0;currentPosY = baseHeight + 10;currentPosX = 25;for (k=0; k<Abs(branchRates); k=k+1){	ks = sortedKeys[k][1];	theKey = bKeys[ks];	aKey = branchRates[theKey]-1;	colorMx = branchColors[aKey%Abs(branchColors)];	psLegend * (""+colorMx[0]+" "+colorMx[1]+" "+colorMx[2]+ " setrgbcolor\n"+currentPosX+" "+currentPosY+" moveto\n");	psLegend * ("(dN/dS = "+Format(0+bKeys[ks],6,3)+"; "+Format(branchLengths[theKey]/totalTreeLength*100,4,0)+ "\\%) show\n");	currentPosY = currentPosY + 20;}newHeight = baseHeight + 20 + Abs(branchRates)*20;psLegend * "showpage";psLegend * 0;repMx = {{"showpage"}{psLegend}};psString = psString ^ repMx;repMx = {{"/PageSize\\ \\[[0-9\\ ]+\\]"}{"/PageSize [612 "+ newHeight+ "]"}};psString = psString ^ repMx;repMx = {{"setfont"}{"setfont\n3 setlinewidth\n1 setlinecap"}};psString = psString ^ repMx;fName = fPath + ".ps";fprintf (fName, CLEAR_FILE,psString);fName = fPath + ".branch_classes";fprintf (fName, CLEAR_FILE,convertMatrixToBranchPart (bestModel));fprintf (stdout, "\n<DIV CLASS = 'RepClassSM' style = 'max-width: 100%'>Unscaled tree with the best (c-AIC) branch partitioning [Get a <a href = '",relativeURL,".pdf'>.pdf</a> version]<p><i>Branches are labeled with Pr{dN&gt;dS}. Legend labels show the total percentage of the tree with the respective dN/dS</i>",				 "\n<p><IMG BORDER='2' WIDTH = '612' HEIGHT = '",newHeight,"' ALT = 'Tree Image' SRC = '",relativeURL,".png'></DIV>");fprintf (stdout, "\n<DIV CLASS = 'RepClassSM' style = 'max-width: 100%'> Get a <a href = '",relativeURL,".branch_classes'>branch partition file</a> suitable for analysis with Standard Analyses&gt;Compartmentalization&gt;BranchClassDNDS.bf in HyPhy.</DIV>");