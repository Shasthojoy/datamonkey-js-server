ExecuteAFile ("../Shared/TreeTools.ibf");
ExecuteAFile ("ProcessorsShared.ibf");

fName			= BASE_OUTPUT_PATH + filePrefix +"_" + suffix[kind] + ".php";
fprintf			(fName, CLEAR_FILE,"<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'><html><head><meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1'><meta http-equiv='refresh' content='60'><title>Almost there...</title></head><body>Generating a report...this page will refresh in 1 minute (or you can try sooner)");


/*---------------------------------------------------------------*/

siteCount 			= 0+(_ExecuteSQL  (slacDBID,"SELECT SITES FROM FILE_INFO"))[0];
dataType			= 0+(_ExecuteSQL  (slacDBID,"SELECT GENCODEID FROM FILE_INFO"))[0];

if (dataType >= 0)
{
	siteCount = siteCount * 3;
}

fscanf		   (rawOut, "Number,NMatrix,Number,String,String,Number,Number,Number",
						timeElapsed,
						_filterSizes,
						treeMode,
						rootedOn,
						modelDescString,
						rvChoice,
						rvRates,
						baselineScore);


fscanf		   		(rawOut, "Matrix", characters);
characterCount		= Columns (characters);

charTable			= {};
for (k = 0; k < characterCount; k = k + 1)
{
	charTable[k] = characters[k];
}
l = Abs (characters[0]);
charTable [-1] = "-";
for (k = 1; k < l; k=k+1)
{
	charTable [-1] = charTable [-1]  + "-";
}

fscanf		  		(rawOut, "NMatrix", rateMatrix);
rateMatrix 		   = (rateMatrix["_MATRIX_ELEMENT_VALUE_*(_MATRIX_ELEMENT_ROW_!=_MATRIX_ELEMENT_COLUMN_)"]);
rateMax			   = Max(rateMatrix,0);
if (rvChoice>0)
{
	fscanf		  		(rawOut, "NMatrix", cI);
}

fscanf		   (rawOut, "Number,String,Matrix", fileCount, consensusTree, nodeMapMatrix);

ASR_Residues_Table                  = {};
ASR_Residues_Table ["PARTITION"]    = "INTEGER";
ASR_Residues_Table ["SEQUENCE"]     = "INTEGER";
ASR_Residues_Table ["SITE"]         = "INTEGER";
ASR_Residues_Table ["JOINT"]        = "TEXT";
ASR_Residues_Table ["MARGINAL"]     = "TEXT";
ASR_Residues_Table ["SAMPLED"]      = "TEXT";
ASR_Residues_Table ["MARGINALP"]    = "FLOAT";
ASR_Residues_Table ["SAMPLEDP"]     = "FLOAT";

_CheckDBID 		  (slacDBID,"ASR_RESIDUES_TABLE",ASR_Residues_Table);

ASR_MarginalDump                    = {};
ASR_MarginalDump ["PARTITION"]    = "INTEGER";
ASR_MarginalDump ["SEQUENCE"]     = "INTEGER";
ASR_MarginalDump ["SITE"]         = "INTEGER";

for (k = 0; k < characterCount; k = k+1)
{
	ASR_MarginalDump[characters[k]] = "FLOAT";
}

_CheckDBID 		  (slacDBID,"ASR_MARGINAL_DUMP",ASR_MarginalDump);
_CheckDBID 		  (slacDBID,"ASR_SAMPLED_DUMP",ASR_MarginalDump);

ASR_PartitionTables                 = {};
ASR_PartitionTables ["PARTITION"]    = "INTEGER";
ASR_PartitionTables ["SPAN"]         = "INTEGER";
ASR_PartitionTables ["TREE"]         = "TEXT";
ASR_PartitionTables ["NODE_MAP"]     = "TEXT";

_CheckDBID 		  (slacDBID,"ASR_PARTITION_TABLES",ASR_PartitionTables);

chunk = 2000;

for (k = 0; k < fileCount; k = k + 1)
{
	fprintf			(fName,"<p>Working on partition ", k+1, "/", fileCount);
	recordsToAdd = {};
	recordsToAddM = {};
	recordsToAddS = {};
	aRecord		 = {};
	aRecord      ["PARTITION"] = k;
	mRecord		 = {};
	mRecord      ["PARTITION"] = k;
	sRecord		 = {};
	sRecord      ["PARTITION"] = k;
	fscanf		   (rawOut, "String,Matrix,NMatrix", a, b, c);
	
	bRecord		 = {};
	bRecord		 ["PARTITION"] = k;
	bRecord		 ["SPAN"]	   = _filterSizes[k][1];
	bRecord		 ["TREE"]	   = a;
	bRecord		 ["NODE_MAP"]  = b;
	
	_InsertRecord (slacDBID, "ASR_PARTITION_TABLES", bRecord);
	
	rows		 = Rows (c);
	
	
	for (r = 0; r < rows; r = r+1)
	{
		aRow 		 = c[r][-1];
		aRecord      ["SEQUENCE"]   = aRow[0];
		aRecord      ["SITE"] 	    = aRow[1];
		aRecord      ["JOINT"] 	    = charTable[aRow[2]];
		aRecord      ["MARGINAL"]   = charTable[aRow[3]];
		aRecord      ["SAMPLED"]    = charTable[aRow[4]];
		mRecord      ["SEQUENCE"]   = aRow[0];
		mRecord      ["SITE"] 	    = aRow[1];
		sRecord      ["SEQUENCE"]   = aRow[0];
		sRecord      ["SITE"] 	    = aRow[1];
		
		aRowP		 = Transpose(aRow [{{0,5}}][{{0,characterCount+5-1}}]);
		for (rr = 0; rr < characterCount; rr = rr+1)
		{
			mRecord[characters[rr]] = aRowP[rr];	
		}
		recordsToAddM[Abs(recordsToAddM)] = mRecord;
		aRecord      ["MARGINALP"]  = Max(aRowP, 0);
		aRowP		 = Transpose(aRow [{{0,characterCount+5}}][{{0,2*characterCount+5-1}}]);
		for (rr = 0; rr < characterCount; rr = rr+1)
		{
			sRecord[characters[rr]] = aRowP[rr];	
		}
		recordsToAddS[Abs(recordsToAddS)] = sRecord;
		aRecord      ["SAMPLEDP"]  = Max(aRowP, 0);
		
		recordsToAdd [Abs(recordsToAdd)] = aRecord;
		
		if (Abs(recordsToAdd) % chunk == 0)
		{
			_InsertMultipleRecords (slacDBID, "ASR_RESIDUES_TABLE", recordsToAdd);
			_InsertMultipleRecords (slacDBID, "ASR_MARGINAL_DUMP", recordsToAddM);
			_InsertMultipleRecords (slacDBID, "ASR_SAMPLED_DUMP", recordsToAddS);
			recordsToAdd = {};
			recordsToAddS ={};
			recordsToAddM = {};		
			fprintf			(fName,"<br>Processed ", r+1, "/", rows, " matrix rows");
		}
	}	
	if (Abs(recordsToAdd))
	{
		_InsertMultipleRecords (slacDBID, "ASR_RESIDUES_TABLE", recordsToAdd);
		_InsertMultipleRecords (slacDBID, "ASR_MARGINAL_DUMP", recordsToAddM);
		_InsertMultipleRecords (slacDBID, "ASR_SAMPLED_DUMP", recordsToAddS);	
	}
}

fscanf (rawOut, "Raw", lfFit);

fprintf (stdout, "<script type='text/javascript' src='http://www.datamonkey.org/wz_tooltip.js'></script><H1 CLASS='SuccessCap'>Ancestral Sequence Reconstruction Results</H1>\n");
lfFile = BASE_OUTPUT_PATH + filePrefix + "_asr.nex";

fprintf (lfFile, CLEAR_FILE, lfFit);

jobFileName = BASE_CGI_URL_STRING + "slacreport.pl?file=" + filePrefix + "&task=22&format=";

fprintf (stdout, "<DIV CLASS='RepClassCT'><b>Reports</b> <a href='",
			        jobFileName,"1' target = '_blank'>[CSV]</a> <a href='",jobFileName,"3",
			        "'>[FASTA]</a> <a href='",filePrefix,"_asr.nex",
			        "'>[HyPhy Model Fit]</a></DIV>");		
		
fprintf (stdout, _makeJobIDHTML(filePrefix));

				 
fprintf (stdout, "<DIV class = 'RepClassSM'><b>Execution summary</b><p>",
				 "Ancestral state reconstrutction was performed in ", 
				 _formatTimeString(timeElapsed), 
				 " wallclock time using ",
				 _getTreeDescriptionTag (treeMode), 
				 " (view as <a href = '", 
				 _getTreeLinkRR (filePrefix, treeMode,0, rootedOn), 
				 "'> [Newick]</a> or ",
				 "<a href = '", 
				 _getTreeLinkRR (filePrefix, treeMode,1, rootedOn), 
				 "'> [PDF]</a>), rooted on <b>", rootedOn, "</b>. Log(L) under the ",modelDescString, " model is ", baselineScore, ". <p><b>", Rows (nodeMapMatrix), "</b> sequences ");

lfFile = BASE_OUTPUT_PATH + filePrefix + "_tree_cons.ps";
fprintf (lfFile, CLEAR_FILE,_returnTreePS (consensusTree, "",1));

for (k = 0; k < Rows(nodeMapMatrix); k=k+1)
{
	lfFile = BASE_OUTPUT_PATH + filePrefix + "_tree_cons_"+k+".ps";
	fprintf (lfFile, CLEAR_FILE,_returnTreePS (consensusTree, "",nodeMapMatrix[k][0]));
}
	
if (fileCount > 1)
{	
	fprintf (stdout,"that correspond to internal nodes in the segment consensus tree (view as <a href = '", 
				 BASE_CGI_URL_STRING,"renderPSImage.pl?file=",filePrefix,"_tree_cons", 
				 "'> [PNG]</a> or ",
				 "<a href = '", 
				 BASE_CGI_URL_STRING,"renderPSImage.pl?file=",filePrefix,"_tree_cons&doPDF", 
				 "'> [PDF]</a>)");
}

fprintf (stdout, " are available for examination and download as a <a href='",jobFileName,"3",
			        "'>[FASTA]</a> file.",
				 "</DIV>\n"
				 );
				 
				 
GARD_SummaryTable                = {};
GARD_SummaryTable ["COL_KEY"]    = "STRING";
GARD_SummaryTable ["COL_VALUE"]  = "STRING";

_CheckDBID 		  (slacDBID,"ASR_SUMMARY",GARD_SummaryTable);

record = {};
record ["COL_KEY"] = "ModelDescription";record ["COL_VALUE"] = modelDescString;_InsertRecord (slacDBID,"ASR_SUMMARY", record);
record ["COL_KEY"] = "TreeMode";     record ["COL_VALUE"] = treeMode;_InsertRecord (slacDBID,"ASR_SUMMARY", record);
record ["COL_KEY"] = "Outgroup";  record ["COL_VALUE"] = rootedOn;_InsertRecord (slacDBID,"ASR_SUMMARY", record);
record ["COL_KEY"] = "SeqCount";  record ["COL_VALUE"] = Rows (nodeMapMatrix);_InsertRecord (slacDBID,"ASR_SUMMARY", record);
record ["COL_KEY"] = "Alphabet"; record ["COL_VALUE"] = characters;_InsertRecord (slacDBID,"ASR_SUMMARY", record);
record ["COL_KEY"] = "Nodemap"; record ["COL_VALUE"] = nodeMapMatrix;_InsertRecord (slacDBID,"ASR_SUMMARY", record);


fprintf (stdout, "<DIV class = 'RepClassSM'><FORM method='GET' name = 'plotForm' action='",BASE_CGI_URL_STRING,"wrapHyPhyBF.pl''><input type = hidden name = 'file' value = 'asr_sequence_report'>View a reconstructed sequence</b>",
				 "<SELECT ID = 'SeqSelector' name = 'arguments'>");
				 
for (k = 0; k < Rows(nodeMapMatrix); k = k + 1)
{
	fprintf (stdout, "<OPTION VALUE = ",filePrefix,"-",k,">",nodeMapMatrix[k][0]);
}

fprintf (stdout, "</SELECT><INPUT TYPE = 'SUBMIT' VALUE = 'Render'><p><img border = '1' src = '", 
				 BASE_CGI_URL_STRING,"renderPSImage.pl?file=",filePrefix,"_tree_cons", 
				 "'></FORM></DIV");
				 
				 