/* DEPS model processor script for datamonkey */


AAString    					= "ACDEFGHIKLMNPQRSTVWY";

ExecuteAFile 			("../Shared/GrabBag.bf");
ExecuteAFile 			("../Shared/AncestralMapper.bf");
ExecuteAFile 			("../Shared/ReadDelimitedFiles.bf");

sscanf (rawIn,"String,String,Number,Number,Number,String",p_model,p_model_longname,rvChoice,rateClasses,treeMode,rootTaxon);

uploadPath 			= BASE_CLUSTER_ACCESS_PATH + filePrefix;


resName			= BASE_OUTPUT_PATH + filePrefix +"_" + suffix[kind] + ".php";
fprintf			(resName, CLEAR_FILE,"<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'><html><head><meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1'><meta http-equiv='refresh' content='60'>",
				"<title>Almost there...</title></head><body>Generating a DEPS report...this page will refresh in a minute (or you can try sooner).");
DataSet							baseAlignment = ReadDataFile (uploadPath);
spoolPATH 						= BASE_OUTPUT_PATH + filePrefix;

DataSetFilter filteredData = CreateFilter (baseAlignment,1);
DATA_FILE_PRINT_FORMAT = 6;
aaFile = BASE_OUTPUT_PATH + filePrefix + ".aa.nex";
fprintf (aaFile, CLEAR_FILE, filteredData);

aaFile = BASE_OUTPUT_PATH + filePrefix + ".aa.fas";
fprintf ( aaFile, CLEAR_FILE );
GetString(seqNames,filteredData,-1);
for ( ii = 0; ii < filteredData.species; ii = ii + 1 ) {
	GetDataInfo (sequenceToPrint, filteredData, ii );
	fprintf ( aaFile, "> ", seqNames [ ii ], "\n", sequenceToPrint, "\n" );
}

trunkPath						= splitFilePath (spoolPATH);
extensionStack					= {};
extensionStack[Abs(extensionStack)] = trunkPath["EXTENSION"];
trunkPath						= trunkPath["DIRECTORY"] + trunkPath["FILENAME"];
reducedTrunk					= splitFilePath (trunkPath);

ACCEPT_ROOTED_TREES				= 1;

while (Abs(reducedTrunk["EXTENSION"]))
{
	extensionStack[Abs(extensionStack)] = reducedTrunk["EXTENSION"];
	reducedTrunk					= reducedTrunk["DIRECTORY"] + reducedTrunk["FILENAME"];
	reducedTrunk					= splitFilePath (reducedTrunk);
}

trunkPath									  = reducedTrunk["DIRECTORY"] + reducedTrunk["FILENAME"];
DataSetFilter					baseFilter	  = CreateFilter (baseAlignment,1);

bySiteFreqs						= {};

COUNT_GAPS_IN_FREQUENCIES = 0;

adder = {1,20}["1"];

for	(s = 0; s < baseFilter.sites; s=s+1)
{
	DataSetFilter 		siteFilter = CreateFilter (baseAlignment,1,siteIndex == s);
	siteF	 = {20,1};
	currentM = siteFilter.species;
	for (z = 0; z < currentM; z = z+1)
	{
		GetDataInfo (charInfo, siteFilter, z, 0);
		k = (adder*charInfo)[0];
		if (k == 1)
		{
			siteF = siteF + charInfo;
		}
	}
	bySiteFreqs [s] = siteF;
}

ExecuteAFile				(spoolPATH + ".base");

rootStateBySite					= {};

fprintf (stdout, "<script type='text/javascript' src='http://www.datamonkey.org/wz_tooltip.js'></script>\n<H1 CLASS='SuccessCap'>DEPS analysis results</H1>\n");	

aaFile = BASE_HTML_URL_STRING + filePrefix + ".aa.nex";
fprintf ( stdout, "<DIV CLASS='RepClassCT'><b>Reports:</b> <a href='",aaFile,"'>[NEXUS_AA]</a>");
fprintf (stdout, _makeJobIDHTML(filePrefix) );

/*check against protein model*/

PMS = _TableExists ( slacDBID, "PMODEL_RESULTS" );
if ( PMS ) {
	sqlString = "";
	sqlString * 128;
	sqlString * ( "SELECT Model from PMODEL_RESULTS where (cAIC==(select min(cAIC) from PMODEL_RESULTS));");
	sqlString * 0;
	pmsModel = _ExecuteSQL (slacDBID, sqlString);
	if ( pmsModel[0] != p_model_longname ) {
		fprintf ( stdout, "<DIV CLASS = 'ErrorTagSM'><b>Warning</b>: Protein Model Selection identified <b>", pmsModel[0], "</b> as the best fit model using cAIC, " );
		fprintf ( stdout, "whereas <b>", p_model_longname, "</b> was used for DEPS analysis.</DIV>\n" );
	}
}
else {
	fprintf ( stdout, "<DIV CLASS = 'ErrorTagSM'><b>Warning</b>: Protein Model Selection has not been performed on this alignment. This may generate misleading results. Please select an appropriate model for your alignment using our Protein Model Selection tool." );
	fprintf (stdout,"\n<form  name='modelChooseForm' method='POST' enctype='multipart/form-data' action='",BASE_CGI_URL_STRING,"dispatchAnalysis.pl'>",
				"\n<input name='filename' type='hidden' value='" ,filePrefix,"'>",
				"<input type='Hidden' name='sequences' value='",filteredData.species,"'>\n",
				"<input type='Hidden' name='sites' value='",filteredData.sites,"'>\n",
				"<input type='Hidden' name='partitions' value='1'>\n",
				"<input type='Hidden' name='method' value='11'>\n",
				"\n<INPUT TYPE='Submit' VALUE='Execute'> an automatic protein model selection tool.</form></div>");
}

resultsFile = BASE_HTML_URL_STRING + filePrefix + "_deps.tar.bz2";
fprintf ( stdout, "<DIV CLASS = 'RepClassSM'>Summary results are printed below. For additional result processing, including temporal trend plots as in the <a href='http://www.ncbi.nlm.nih.gov/pubmed/18511426' CLASS = 'INFO' onmouseover = \"Tip('Mol Biol Evol. 2008 Sep;25(9):1809-24')\">Methodology Paper</a>, download <a href='",resultsFile,"'>results</a> and see the <a href='http://hyphy.ucsd.edu/wiki/DEPSProcessing'>Directional selection page</a> for details.</DIV>" );


DEPS_Results		=			spoolPATH + "_bysite.csv";
fscanf							(DEPS_Results, "Lines", DIR_matrix);
pvString			= 			splitOnRegExp (DIR_matrix[1], "\\,");


test_p_values					 = {20,2}["_MATRIX_ELEMENT_ROW_"];
for	(s = 0; s < 20; s=s+1)
{
	test_p_values[s][0] = 0+pvString[s+1];
}
test_p_values      				 = test_p_values % 0;
rejectedHypotheses   			 = {};
parameterEstimates	 			 = {20,3}["1"];
sitesByResidue					 = {};

ancCachesByResidue  = {};
rootStatesByResidue = {};
rootIndexByResidue	= {};

for (k=0; k<20; k=k+1)
{
	if (test_p_values[k][0] < (0.05/(20-k)))
	{
		residueIndex								 = test_p_values[k][1];
		rejectedHypotheses  [residueIndex]           = 1;
		rejectedHypotheses  [AAString[residueIndex]] = 1;
		parameterEstimates  [residueIndex][0]		 = test_p_values[k][0];		
		ExecuteAFile		(spoolPATH + "." + AAString[residueIndex]);
		ancCacheID 						= _buildAncestralCache ("lfb", 0);
		ancCachesByResidue[k] 			= ancCacheID;
		parameterEstimates  [residueIndex][1]		 = rateBiasTo;
		parameterEstimates  [residueIndex][2]		 = P_bias;
		rootStatesByResidue[residueIndex]			 = {};
		rootIndexByResidue[residueIndex]			 = {};
		for	(s = 0; s < baseFilter.sites; s=s+1)
		{
			_rss = _rootState (ancCacheID,s);
			(rootStatesByResidue[residueIndex])[s] = _rss["CHAR"];
			(rootIndexByResidue[residueIndex])[s]  = _rss["INDEX"];
		}		
	}
	else
	{
		break;
	}
}

for (s=2; s<Columns(DIR_matrix); s=s+1)
{
	siteInfo 	= splitOnRegExp(DIR_matrix[s],"\\,");
	siteIndex 	= 0+siteInfo[0];
	for (r = 1; r < 21; r=r+1)
	{
		thisBF = 0 + siteInfo[r];
		if (thisBF >= 100.)
		{
			sitesByResidue[r-1] = sitesByResidue[r-1] + 1;
		}
	}
}

pCount = 0;

baselineBL						= BranchLength (givenTree,-1);
referenceL						= (baselineBL * (Transpose(baselineBL)["1"]))[0];

bySiteAVL					= {};
keepSiteResidues			= {};

for (s=2; s<Columns(DIR_matrix); s=s+1)
{
	siteInfo 	= splitOnRegExp(DIR_matrix[s],"\\,");
	siteIndex 	= 0+siteInfo[0];
	myBFs		= {};
	tRI			= 0;
	for (r = 1; r < 21; r=r+1)
	{
		thisBF = 0 + siteInfo[r];
		if (thisBF >= 100.)
		{
			myBFs[r-1] = thisBF;
			tRI = r-1;
		}
	}
	if (Abs(myBFs))
	{
		psOutput					= spoolPATH + "." + siteIndex + ".ps";
		fprintf						(psOutput, CLEAR_FILE, KEEP_OPEN);
	
		thisResidue = {};
		
		thisResidue [0] = returnSiteSignature (bySiteFreqs[siteIndex-1]);
		thisResidue [1] = (rootStatesByResidue[tRI]) [siteIndex-1];
		
		thisSite 		= _substitutionsBySite (ancCachesByResidue[tRI],siteIndex-1);
		thisSitePS 		= _mapSubstitutionsBySite2 (ancCachesByResidue[tRI],siteIndex-1,1,tRI);
		thisSitePS      = thisSitePS ^ {{"showpage"}{"/Times-Roman findfont 12 scalefont setfont 500 770 moveto (Site " + siteIndex +") show stroke\nshowpage"}};
		fprintf			(psOutput, "\n" , thisSitePS);
		fprintf			(psOutput, CLOSE_FILE);
		
		subBufferer = ""; subBufferer * 128;
		
		
		doComma = 0;
		for (char1 = 0; char1 < 20; char1 = char1+1)
		{
			for (char2 = char1+1; char2 < 20; char2 = char2+1)
			{
				if (char1 != char2 && ((thisSite["COUNTS"])[char1][char2]+(thisSite["COUNTS"])[char2][char1]))
				{	
					ccountf = (thisSite["COUNTS"])[char1][char2];
					ccountb = (thisSite["COUNTS"])[char2][char1];
					if (doComma)
					{
						subBufferer *("<br>");
					}
					doComma = 1;
					subBufferer * (AAString[char1] + "<sub>" + ccountb + "</sub>&harr;<sub>" + ccountf + "</sub>" + AAString[char2]);
				}
			}
		}

		
		subBufferer*0;
		thisResidue [2] = subBufferer;
		subBufferer * 128; 
		subBufferer2 = ""; subBufferer2 * 128;
		subBufferer3 = ""; subBufferer3 * 128;
		char1 = 0;
		
		for (r = 0; r < 20; r=r+1)
		{
			if (myBFs[r])
			{
				if (char1)
				{
					subBufferer * "<br>";
					subBufferer2 *"<br>";
					subBufferer3 * ":";
				}
				subBufferer  * (AAString[r] + ":");
				subBufferer2 * (AAString[r] + ":");
				subBufferer3 * (AAString[r]);				
				if (myBFs[r] > 10000)
				{
					subBufferer *  ("&gt;10<sup>5</sup>");
				}
				else
				{
					subBufferer *  (Format(myBFs[r],6,1));				
				}
				subBufferer2 * guessSelectionKind ((rootIndexByResidue[tRI]) [siteIndex-1], r,bySiteFreqs[siteIndex-1],thisSite["COUNTS"]);
				char1 = char1+1;
			}
		}
		subBufferer*0; subBufferer2 * 0; subBufferer3 * 0;
		thisResidue [3] = subBufferer;
		thisResidue [4] = subBufferer2;
		keepSiteResidues[siteIndex] = subBufferer3;
		bySiteAVL[siteIndex] = thisResidue;
	}
}


byResidueAVL					= {};
labelKeysR						= {};
labelKeysR[0] = "Residue";
labelKeysR[1] = "p-value";
labelKeysR[2] = "Bias term";
labelKeysR[3] = "Proportion of affected sites";
labelKeysR[4] = "Directionally evolving sites";

for (k=0; k<20; k=k+1)
{
	if (parameterEstimates[k][0] != 1)
	{
		residueReport		= {};
		residueReport		[0] = Format(parameterEstimates[k][0],8,4);
		residueReport		[1] = Format(parameterEstimates[k][1],5,2);
		residueReport		[2] = Format(100*parameterEstimates[k][2],5,2) + "%";
		residueReport		[3] = sitesByResidue[k];
	
		byResidueAVL[AAString[k]] = residueReport;
	}
}


DEPS_ResultTable 					= {};
DEPS_ResultTable	["Model"]		= "TEXT";
DEPS_ResultTable 	["Sites"] 		= "INTEGER";
DEPS_ResultTable 	["Residues"] 	= "INTEGER";
_CheckDBID (slacDBID,"DEPS_SUMMARY",DEPS_ResultTable);

record = {};
record["Model"] 		= p_model_longname;
record["Sites"] 		= Abs ( bySiteAVL );
record["Residues"] 		= Abs ( byResidueAVL );
_InsertRecord (slacDBID,"DEPS_SUMMARY", record);

summaryAVL												= {};
summaryAVL	["Sequences"]								= baseFilter.species;
summaryAVL	["Sites"]									= baseFilter.sites;
summaryAVL	["Tree Length (subs/site)"]					= Format (referenceL, 5,2);
summaryAVL	["Directionally selected residues (DEPS)"]  = Abs(byResidueAVL);
summaryAVL	["Directionally selected sites (DEPS)"]		= Abs(bySiteAVL);

fprintf							(stdout, "<DIV CLASS = 'RepClassSM' style = 'font-weight: bolder;'>Analysis statistics",echoAVLAsTableThisFile (summaryAVL, 0, 0, 0, 12),"</DIV>\n");


if ( Abs(byResidueAVL) > 0 ) {

	labelKeys						= {};
	labelKeys[0] = "Site";
	labelKeys[1] = "Composition";
	labelKeys[2] = "MRCA Residue";
	labelKeys[3] = "Inferred Substitutions";
	labelKeys[4] = "DEPS EBF";
	labelKeys[5] = "Selection kind";
	fprintf							(stdout, "<DIV CLASS = 'RepClassSM' style = 'font-weight: bolder;'>Selected residue report ",echoAVLAsTableThisFile (byResidueAVL, labelKeysR, 1, 0, 12), "</DIV>\n");
	
}

addSiteTrees = 1;

if ( Abs ( bySiteAVL ) > 0 ) {

	labelKeys						= {};
	labelKeys[0] = "Site";
	labelKeys[1] = "Composition";
	labelKeys[2] = "MRCA Residue";
	labelKeys[3] = "Inferred Substitutions";
	labelKeys[4] = "DEPS EBF";
	labelKeys[5] = "Selection kind";
	if ( addSiteTrees ) {
		labelKeys[6] = "Site report";
		fprintf							(stdout, "<DIV CLASS = 'RepClassSM' style = 'font-weight: bolder;'>Selected sites report ",echoAVLAsTableAddSites (bySiteAVL, labelKeys, keepSiteResidues, 12), "</DIV>\n");
	}	
	else {
		fprintf							(stdout, "<DIV CLASS = 'RepClassSM' style = 'font-weight: bolder;'>Selected sites report ",echoAVLAsTableThisFile (bySiteAVL, labelKeys, 1, 0, 12), "</DIV>\n");
	}
}

fprintf (stdout, "<DIV CLASS = 'RepClassSM' style = 'font-weight: bolder;'>" );
fscanf ("../Formats/deps_report","Raw",deps_Legend);
fprintf (stdout, deps_Legend);
fprintf (stdout, "</DIV>");



/* ------------------------------------------------------------------------------- */

function						guessSelectionKind (root, target, freqs, subCounts)
{
	toTarget = subCounts[-1][target]; toTarget     = ((Transpose(toTarget["_MATRIX_ELEMENT_ROW_!=target"]))*toTarget)[0];
	fromTarget = subCounts[target][-1]; fromTarget = (fromTarget*(Transpose(fromTarget["_MATRIX_ELEMENT_COLUMN_!=target"])))[0];

	
	if (toTarget > fromTarget) /* more to than from */
	{
		if (freqs[target] >= toTarget*2)
		{
			return "(Partial) selective sweeps";			
		}
		else
		{
			return "Convergent evolution/Repeated Substitutions";
		}
	}

	if (freqs[target] >= toTarget*2)
	{
		return "Frequency dependent selection";			
	}
	
	return "Variable site/toggling";
}

/* ------------------------------------------------------------------------------- */

function 						returnSiteSignature (countVector)
{	
	countVector2 = {20,2}["_MATRIX_ELEMENT_ROW_"];
	for (_cc = 0; _cc < 20; _cc = _cc+1)
	{
		countVector2 [_cc][0] = countVector[_cc];
	}
	countVector2 = countVector2 % 0;
	
	sigString = "";
	sigString * 128;
	for (_cc = 19; _cc >=0 && countVector2[_cc][0]; _cc = _cc-1)
	{
		sigString * (AAString[countVector2[_cc][1]] + "<sub>" + countVector2[_cc][0] + "</sub>");
	}
	sigString * 0;
	return sigString;
}

/*--------------------------------------------------------------------------------------------------------------------*/


function 		echoAVLAsTableAddSites (theData, theKeys, daResidues, tFontSize)
{ 

	_resStr = ""; 
	_resStr * 128;
	_resStr * "<TABLE BORDER = '0' cellspacing = '1px' cellpadding = '5px' style = 'padding:10px'>";

	/* print the column labels*/
	if (Abs(theKeys))
	{
		_rc = Abs (theKeys)-1;
		_resStr * "\n<TR CLASS = 'HeaderClassSM'>";
		for (_k=0; _k <= _rc; _k=_k+1)
		{
			_resStr * ("<TH>" + theKeys[_k] + "</TH>");
		}
		_resStr * ("</TR>\n");
	}

	_avlSize = Abs  (theData);
	_avlKeys = Rows (theData);
	
	for (_k=0; _k<_avlSize;_k=_k+1) /* for all sig sites */
	{
		_resStr * ("<TR CLASS = 'ModelClass" + (1+_k%2) + "' style = 'padding:3px; text-align: left; font-size: " + tFontSize+"px; text-indent: 0px;'>");	
		_resStr * ("<TH>"+_avlKeys[_k]+"</TH>");
		for (_k2 = 0; _k2 < _rc-1; _k2 = _k2+1) /* for all data fields */
		{
			_resStr *  ("<TD>"+(theData[_avlKeys[_k]])[_k2]+"</TD>");						 	
		}
		/* print the site report : loop over all targets for the site */
		siteResiduesToPrint = splitOnRegExp ( (daResidues[_avlKeys[_k]]), ":" );
		
		_resStr * ( "<TD style = 'font-size: " + tFontSize + "px;'>" );
		char1 = 0;
		for ( _k3 = 0; _k3 < Abs (  siteResiduesToPrint ); _k3 = _k3 + 1 ) {
			if ( char1 ) {
				_resStr * ( "<br>" );
			}
			_resStr * ("<a href='" + BASE_CGI_URL_STRING +"DEPSSiteMap.pl?file="+filePrefix+"&site="+_avlKeys[_k]+"&aa="+siteResiduesToPrint[_k3]+"&mode=0'>[target:&nbsp;"+siteResiduesToPrint[_k3]+"]</a>");
			char1 = char1 + 1;
		}
		_resStr * ("</TD></TR>\n");	
	}	
	_resStr * ("</TABLE>\n");
	_resStr * 0;
	return _resStr;
}


function		echoAVLAsTableThisFile (theData, theKeys, avlKind, avlMap, tFontSize)
{
	_resStr = ""; _resStr * 128;
	if (doPlainText == 0)
	{
		_resStr * "<TABLE BORDER = '0' cellspacing = '1px' cellpadding = '5px' style = 'padding:10px'>";
	}
	if (Abs(theKeys))
	{
		_rc = Abs (theKeys)-1;
		if (doPlainText == 0)
		{
			_resStr * "\n<TR CLASS = 'HeaderClassSM'>";
			for (_k=0; _k <= _rc; _k=_k+1)
			{
				_resStr * ("<TH>" + theKeys[_k] + "</TH>");
			}
			_resStr * ("</TR>\n");
		}
		else
		{
			fprintf (stdout, theKeys[0]);
			for (_k=1; _k <= _rc; _k=_k+1)
			{
				_resStr * ("," + theKeys[_k]);
			}		
		}
	}

	_avlSize = Abs  (theData);
	_avlKeys = Rows (theData);
	
	if (avlKind == 0)
	{
		for (_k=0; _k<_avlSize;_k=_k+1)
		{
			_resStr * ("<TR CLASS = 'ModelClass" + (1+_k%2) + "' style = 'padding:3px; text-align: left; font-size: " + tFontSize + "px;'><TH>"+
							 _avlKeys[_k]+
							 "</TH><TD>"+
							 theData[_avlKeys[_k]]+
							 "</TR>");
		}	
	}
	else
	{
	
		for (_k=0; _k<_avlSize;_k=_k+1)
		{
			if (doPlainText == 0)
			{
				_resStr * ("<TR CLASS = 'ModelClass" + (1+_k%2) + "' style = 'padding:3px; text-align: left; font-size: " + tFontSize+"px; text-indent: 0px;'>");	
			}
				
			if (avlKind == 1)
			{	
				if (doPlainText == 0)
				{
					_resStr * ("<TH>"+_avlKeys[_k]+"</TH>");
					for (_k2 = 0; _k2 < _rc; _k2 = _k2+1)
				    {
				    	_resStr *  ("<TD>"+
									 (theData[_avlKeys[_k]])[_k2]+
									 "</TD>");
									 	
					}
				}
				else
				{
					fprintf (stdout,"\n",_avlKeys[_k]);
					for (_k2 = 0; _k2 < _rc; _k2 = _k2+1)
				    {
				    	_resStr * ("," + (theData[_avlKeys[_k]])[_k2]);
									 	
					}	
				}
			}
			else
			{
		    	_resStr * ("<TH>" + (_k+1) + "</TH>");
		    	
				for (_k2 = 0; _k2 < _rc; _k2 = _k2+1)
			    {
			    	if (_k2 == 0 && Abs(avlMap["LINK"]))
			    	{
			    		theLink = avlMap["LINK"] ^ {{"THELINK",(theData[_avlKeys[_k]])[avlMap[0]]}};
			    		_resStr * ("<TD><a href = '", theLink, "'>" + (theData[_avlKeys[_k]])[avlMap[_k2]] + "</a></TD>");
			    	}
			    	else
			    	{			
			    		_resStr * ("<TD>" + (theData[_avlKeys[_k]])[avlMap[_k2]] + "</TD>");
					}	
				}	
					
			}
							 
			if (doPlainText == 0)
			{
				_resStr * ("</TR>\n");
			}
		}	
		
	}
	if (doPlainText == 0)
	{
		_resStr * ("</TABLE>\n");
	}
	_resStr*0;
	return _resStr;
}