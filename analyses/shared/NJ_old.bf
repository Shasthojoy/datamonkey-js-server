if (dataType == 0) /* nucleotide */{	ExecuteAFile ("TN93.def");}else/* protein */{	ExecuteAFile ("pDistanceProt.def");}/* ________________________________________________________________________________________________*/function TreeMatrix2TreeString (doLengths){	treeString = "";	p = 0;	k = 0;	m = treeNodes[0][1];	n = treeNodes[0][0];	d = treeString*(Rows(treeNodes)*25);	while (m)	{			if (m>p)		{			if (p)			{				d = treeString*",";			}			for (j=p;j<m;j=j+1)			{				d = treeString*"(";			}		}		else		{			if (m<p)			{				for (j=m;j<p;j=j+1)				{					d = treeString*")";				}			}				else			{				d = treeString*",";			}			}		if (n<filteredData.species)		{			GetString (nodeName, filteredData, n);			d = treeString*nodeName;		}		if (doLengths>.5)		{			nodeName = ":"+treeNodes[k][2];			d = treeString*nodeName;		}		k=k+1;		p=m;		n=treeNodes[k][0];		m=treeNodes[k][1];	}	for (j=m;j<p;j=j+1)	{		d = treeString*")";	}		d=treeString*0;	return treeString;}/* ________________________________________________________________________________________________*/function InferTreeTopologyFromMatrix (distancesFlag){	MESSAGE_LOGGING 		 	= 1;	cladesMade 					= 1;		if (filteredData.species == 2)	{		d1 = distanceMatrix[0][1]/2;		treeNodes = {{0,1,d1__},					 {1,1,d1__},					 {2,0,0}};					 		cladesInfo = {{2,0}};	}	else	{		if (filteredData.species == 3)		{			d1 = (distanceMatrix[0][1]+distanceMatrix[0][2]-distanceMatrix[1][2])/2;			d2 = (distanceMatrix[0][1]-distanceMatrix[0][2]+distanceMatrix[1][2])/2;			d3 = (distanceMatrix[1][2]+distanceMatrix[0][2]-distanceMatrix[0][1])/2;			treeNodes = {{0,1,d1__},						 {1,1,d2__},						 {2,1,d3__}						 {3,0,0}};						 			cladesInfo = {{3,0}};				}		else		{				njm = (distanceMatrix > methodIndex)>=filteredData.species;							treeNodes 		= {2*(filteredData.species+1),3};			cladesInfo	    = {filteredData.species-1,2};						for (i=Rows(treeNodes)-1; i>=0; i=i-1)			{				treeNodes[i][0] = njm[i][0];				treeNodes[i][1] = njm[i][1];				treeNodes[i][2] = njm[i][2];			}			for (i=Rows(cladesInfo)-1; i>=0; i=i-1)			{				cladesInfo[i][0] = njm[i][3];				cladesInfo[i][1] = njm[i][4];			}						njm = 0;		}	}	distanceMatrix = 0;	return TreeMatrix2TreeString(distancesFlag);}/* ________________________________________________________________________________________________*/function InferTreeTopology(distancesFlag){	InitializeDistances (0);	distanceMatrix = {filteredData.species,filteredData.species};			for (i = 0; i<filteredData.species; i=i+1)	{		for (j = i+1; j<filteredData.species; j = j+1)		{			distanceMatrix[i][j] = ComputeDistanceFormula (i,j);		}	}	return InferTreeTopologyFromMatrix (distancesFlag);}